#Algoritmo de busqueda de un grafo por BFS(con la cola)

def vecinotes(diccionario, grafo):
    queue = []
    for node in grafo.nodes():
        if diccionario == {}:
            queue = [node]
            diccionario[node] = 0

        while len(queue) != 0:
            nodo_actual = queue[0]
            queue.pop(0)
            
            for vecino in grafo.neighbors(nodo_actual):
                if vecino not in diccionario:
                    diccionario[vecino] = diccionario[nodo_actual] + 1
                    queue.append(vecino)
    
    return diccionario

#Lo mismo que el de arriba pero a mi manera

def vecinotes(graph):
    nodos_vistos = set()
    lista_resultante = []
    
    for node in grafo.nodes():
        
        queue = []
        subqueue = []
        
        if node in nodos_vistos:
            continue
        
        queue.append(node)
        subqueue.append(node)
        nodos_vistos.add(node)
        
        while len(queue) != 0:
            
            current_node = queue.pop(0)
            
            for vecino in grafo.neighbors(current_node):
                
                if vecino in nodos_vistos:
                    continue
                
                queue.append(vecino)
                nodos_vistos.add(vecino)
                subqueue.append(vecino)

        lista_resultante.append(subqueue)
    
    for sublist in lista_resultante:
        sublist.sort()
    
    lista_resultante.sort(key=len)
    
    return lista_resultante

#Ejercicio de encontrar el camino más corto y guardar el camino(con BFS)

def bfs_camino_mas_corto(grafo, inicio, fin):
    queue = [(inicio, [inicio])]  # Cada entrada tiene (nodo_actual, camino_recorrido)
    visitados = set()
    visitados.add(inicio)

    while queue:
        nodo_actual, camino = queue.pop(0) # Se pone el nodo y el camino para cuando llames al nodo tengas el camino guardado desde el inicio hasta ese nodo

        if nodo_actual == fin:
            return camino  # ¡Encontramos el camino más corto!

        for vecino in grafo[nodo_actual]:
            if vecino not in visitados:
                visitados.add(vecino)
                queue.append((vecino, camino + [vecino]))

    return None  # No hay camino

#Algoritmo de busqueda de un grafo por DFS(con la pila)

def vecinotes(diccionario, grafo):
    for nodo in grafo.nodes():
        if nodo not in diccionario:
            pila = [nodo]
            diccionario[nodo] = 0
            
            while len(pila) != 0:
                nodo_actual = pila.pop()
                
                for vecino in grafo.neighbors(nodo_actual):
                    if vecino not in diccionario:
                        diccionario[vecino] = diccionario[nodo_actual] + 1
                        pila.append(vecino)

    return diccionario

#Comprobar si el grafo tiene ciclo con DFS(forma retorcida de COJONES)333

def tiene_ciclo(grafo):
    nodos_vistos = set()

    for nodo in grafo.nodes():
        if nodo not in nodos_vistos:
            # Stack con (nodo_actual, nodo_padre)
            stack = [(nodo, None)]

            while stack:
                actual, padre = stack.pop()
                if actual in nodos_vistos:
                    continue

                nodos_vistos.add(actual)

                for vecino in grafo.neighbors(actual):
                    if vecino not in nodos_vistos:
                        stack.append((vecino, actual))
                    elif vecino != padre:
                        # Hemos encontrado un ciclo
                        return True

    return False

#Problema de encontrar la distancia más corta con BFS(se utiliza este algoritmo porque el BFS se usa para calcular la distancia más corta, si quisieras calcular el sendero más corto se usaría DFS o BackTracking)

def vecinotes(grafo, inicio, final):
    if inicio == final:
        return 0

    # Inicializamos la "cola" como una lista y un conjunto para nodos visitados
    cola = [(inicio, 0)]  # Usamos una lista en lugar de deque
    visitados = set()

    while cola:
        nodo_actual, distancia = cola.pop(0)  # Usamos pop(0) en lugar de popleft()

        if nodo_actual == final:
            return distancia

        visitados.add(nodo_actual)

        for vecino in grafo.neighbors(nodo_actual):
            if vecino not in visitados:
                cola.append((vecino, distancia + 1))
                visitados.add(vecino)

    return -1

#Problema resuelto con DFS que sirve para saber si existe algún camino entre el nodo1 y el nodo2.

def vecinotes(grafo, nodo1, nodo2):
    path = []
    for node in grafo.nodes():
        if node == nodo1:
            path.append(node)
            pila = [node]
            
            while len(pila) != 0:
                nodo_actual = pila.pop()
                
                for vecino in grafo.neighbors(nodo_actual):
                    if vecino not in path:
                        if vecino == nodo2:
                            path.append(vecino)
                            return(f"Existe un camino entre {nodo1} y {nodo2}")
                        else:
                            path.append(vecino)
                            pila.append(vecino)
    
    return f"No hay ningún camino entre el {nodo1} y {nodo2}"

#Bactracking que hace todos los caminos posibles donde solo puedes pasar una vez por cada nodo.

def vecinotes(grafo, nodo1, nodo2):
    
    def dfs(nodo_actual, camino):
        
        if nodo_actual == nodo2:
            soluciones.append(list(camino))
            return
        
        for vecino in grafo.neighbors(nodo_actual):
            if vecino not in camino:
                camino.append(vecino)
                dfs(vecino, camino)
                camino.pop()
    
    soluciones = []
    dfs(nodo1, [nodo1])
    
    return soluciones

#Problema del submarino para practicar

def solve(input_list):
    # Construir el grafo a partir del input
    graph ={}

    for line in input_list:
        u, v = line.split('-')
        if u not in graph:
            graph[u] = []
        if v not in graph:
            graph[v] = []
        graph[u].append(v)
        graph[v].append(u)

    all_paths = []
    visited = set()  # No es necesario marcar "start" como visitada
    path = ['start']

    # Función DFS para buscar todas las rutas válidas
    def dfs(cave, visited, path, all_paths):
        # Si hemos llegado a la cueva "end", añadimos la ruta actual
        if cave == 'end':
            all_paths.append(list(path))
            return #Vuelve a la recursión anterior

        # Explorar todas las cuevas conectadas
        for neighbor in graph[cave]:
            if neighbor == 'start':  # No podemos volver a "start"
                continue

            if neighbor in visited:  # Evitar revisitar cuevas pequeñas
                continue

            # Marcar la cueva como visitada si es pequeña
            if neighbor.islower():
                visited.add(neighbor)

            path.append(neighbor)
            dfs(neighbor, visited, path, all_paths)

            # El pop se realiza para volver al nivel anterior 
            path.pop()
            if neighbor.islower():
                visited.remove(neighbor)

     # Iniciar DFS desde la cueva "start"
    dfs('start', visited, path, all_paths) #Esta función solo salta una vez y es la que incia la función dfs!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    num_solutions = len(all_paths)
    return num_solutions, all_paths


if "__main__" == __name__:
    
    input_list = (('start-A'), ('start-b'), ('A-c'), ('A-b'), ('b-d'), ('A-end'), ('b-end'))
    cave = 'start'
    visited = set()
    path = ['start']
    all_paths = []
    resultado = solve(input_list)

    print(resultado)

#Se podría poner asi también el problema del submarino

import networkx as nx

def crear_grafo(input_list): #Función para crear el grafo
    grafo = nx.Graph()
    nodos = []
    
    for tupla in input_list[1:]:
        u = tupla[0]
        v = tupla[1]
        if u not in nodos:
            nodos.append(u)
            grafo.add_node(u)
        elif v not in nodos:
            nodos.append(v)
            grafo.add_node(v)
        
        grafo.add_edge(u, v)
    
    return grafo

def dfs(grafo, cave, visited, path, all_paths):
    if cave == 'end':
        all_paths.append(list(path)) #Mete en la lista all_paths una lista con la ruta actual
        return #Después de meter la ruta actual salta a la recursión anterior
        
    for vecino in grafo.neighbors(cave): #Bucle escpecífico a nivel normal solo para los vecino del primer nodo en el momento que se hayan explorado todas las combinaciones con cada vecino se acaba el bucle
            
        if vecino == 'start': #Si el vecino es start se salta ya que las rutas no pasan dos veces por start
            continue
            
        if vecino in visited: #Si está en visitados significa que es minúscula y ya se ha pasado una vez, y no se puede pasar dos veces, entonces se ignora
            continue
            
        if vecino.islower(): #Si es minúscula y no ha saltado la condición de antes significa que es minúscula y no se ha pasado ninguna vez por el nodo por lo cuál se mete en visited porque acabamos de pasar sobre él
            visited.add(vecino)
            
        path.append(vecino) #Si es minúscula en la condición anterior se metió en visited y ahora se mete en el camino de la ruta, si es mayúscula simplemente se mete en la ruta
        dfs(grafo, vecino, visited, path, all_paths) #Se calculan todos los caminos con el vecino (cabe destacar que en esta llamada recursiva todos los parámetros almacenan los valores de llamadas recursivas anteriores excepto cave que se cambia por vecino)
            
        #Luego de explorarse todas las combinaciones de la iteración con la línea anterior se llega a esta parte del código    
            
        path.pop() #Se quita al vecino y se vuelve un paso atrás
        if vecino.islower(): #Se quita al vecino para que no interfiera en otras rutas ya que en la ruta que acabamos de calcular al vecino ya lo hemos pasado una vez pero en otras no
            visited.remove(vecino)
    
    num_solutions = len(all_paths) #Se cuentan cuantas rutas diferentes hay
    return num_solutions, all_paths #Se devuelve el número de rutas diferentes que hay y la lista con todas las rutas


if "__main__" == __name__:
    
    #Parámetros que se utilizan en este problema
    input_list = (7, ('start', 'A'), ('start', 'b'), ('A', 'c'), ('A', 'b'), ('b', 'd'), ('A', 'end'), ('b', 'end'))
    grafo = crear_grafo(input_list)
    cave = 'start'
    visited = set()
    path = ['start']
    all_paths = []
    resultado = dfs(grafo, cave, visited, path, all_paths)

    print(resultado)

def maxymin(arr, left, right): # 0 y 1
    
    if left == right:
        return [arr[left], arr[left]]
    
    medio = (left + right) // 2 # 0
    
    elemento_izq = maxymin(arr, left, medio) # (8, 3)
    elemento_der = maxymin(arr, medio + 1, right) # [7, 7]
    
    maximo = max(elemento_izq[0], elemento_der[0]) # 8
    minimo = min(elemento_izq[1], elemento_der[1]) # 3
    
    return (maximo, minimo) # (8, 3)


if __name__ == "__main__":
    
    arr = [3, 8, 7, 2, 9]
    resultado = maxymin(arr, 0, len(arr) - 1)
    print(resultado)

#Memorization con barra de longitud

def max_corte_barra(n, precios):
    # Diccionario para memorización
    memo = {}

    def dp(longitud):
        # Caso base: no hay barra
        if longitud == 0:
            return 0
        
        # Si ya calculamos este estado, devolverlo
        if longitud in memo:
            return memo[longitud]
        
        # Beneficio máximo para la longitud actual
        max_beneficio = 0
        for i in range(1, longitud + 1):
            # Si cortamos la barra en i, el beneficio es precios[i-1] + dp(longitud - i)
            max_beneficio = max(max_beneficio, precios[i-1] + dp(longitud - i))
        
        # Guardar el resultado en la memorización
        memo[longitud] = max_beneficio
        return max_beneficio

    # Llamar a la función recursiva para la barra completa
    return dp(n)

# Ejemplo de uso
n = 8
precios = [1, 5, 8, 9, 10, 17, 17, 20]
print(max_corte_barra(n, precios))  # Salida: 22

#Primer ejercicio que valía puntos(el que me tocó a mi)

import networkx as nx

def crear_grafo(input_list):
    grafo = nx.Graph()
    nodos = []
    
    for tupla in input_list[1:]:
        u = tupla[0]
        v = tupla[1]
        if u not in nodos:
            nodos.append(u)
            grafo.add_node(u)
        elif v not in nodos:
            nodos.append(v)
            grafo.add_node(v)
        
        grafo.add_edge(u, v)
    
    return grafo

def vecinotes(grafo, lista):
    
    solucion = []
    visitados = set()
    
    for node in grafo.nodes():
        if node not in visitados:
            visitados.add(node)
            solucion.append(node)
            pila = [node]
            
            while len(pila) != 0:
                nodo_actual = pila.pop()
                
                for vecino in grafo.neighbors(nodo_actual):
                    if vecino not in solucion:
                        visitados.add(vecino)
                        solucion.append(vecino)
                        pila.append(vecino)
            
            lista.append(sorted(solucion))
            solucion = []
    
    return sorted(lista, key=len)


if "__main__" == __name__:
    
    input_list = (4, (4, 3), (5, 6), (6, 2), (1, 1))
    grafo = crear_grafo(input_list)
    resultado = vecinotes(grafo, [])
    print(resultado)

#Backtracking clásico, problema de la devolución de monedas exactas

def solve(monedas, cambio, solucion, soluciones, indice):
    # Caso base: si el cambio se alcanza exactamente
    if sum(monedas[i - 1] for i in solucion) == cambio:
        soluciones.append(list(solucion))  # Guardamos una copia de la solución actual (índices)
        return
    
    # Si el cambio no puede alcanzarse (es mayor o no hay más monedas)
    if sum(monedas[i - 1] for i in solucion) > cambio or indice >= len(monedas):
        return
    
    # Exploramos cada moneda comenzando desde el índice actual
    for i in range(indice, len(monedas)):
        # Agregamos el índice de la moneda actual a la solución
        solucion.append(i + 1)
        # Llamada recursiva para intentar completar el cambio
        solve(monedas, cambio, solucion, soluciones, i + 1)  # Avanzamos al siguiente índice
        # Retroceso: quitamos el índice actual y probamos otra opción
        solucion.pop()
    
    return


if "__main__" == __name__:
    monedas = [5, 2, 1, 10, 10, 2]
    cambio = 12
    soluciones = []
    solve(monedas, cambio, [], soluciones, 0)  # Llamada inicial al algoritmo
    print(soluciones)

#Mismo problema que arriba, pero solo con los parámetros que te da el problema

def solve(coins, change):
    solutions_list = []

    def dfs(current_indices, current_sum, start):
        # Caso base: si alcanzamos exactamente el cambio, guardamos la solución
        if current_sum == change:
            solutions_list.append(list(current_indices))  # Guardar una copia de la combinación actual
            return
        
        # Si superamos el cambio, no continuamos explorando
        if current_sum > change:
            return
        
        # Recorrer todas las monedas comenzando desde el índice actual
        for i in range(start, len(coins)):
            # Agregar el índice actual a la combinación y avanzar
            current_sum += coins[i]
            current_indices.append(i + 1)
            dfs(current_indices, current_sum, i + 1)
            current_indices.pop()  # Retroceso para probar otra combinación
            current_sum -= coins[i]

    # Llamada inicial al DFS
    dfs([], 0, 0)
    return solutions_list


if __name__ == "__main__":
    coins = [5, 2, 1, 10, 10, 2]
    change = 12
    result = solve(coins, change)
    print(result)

#Algoritmo que funciona con fuerza bruta

def next_number(digits, base):
    # ...
    next_digits = digits.copy()

    # Añade tu código aqui
    # ...
    carry = 1
    for i in range(len(next_digits)-1,-1,-1):
        next_digits[i] = next_digits[i] + carry
        if next_digits[i] == base:
            next_digits[i] = 0
        else:
            carry = 0
            break


    return next_digits
#----------------------------------------------------------
class My_Iterator:

    def __init__(self, num_digits, base):
        # 2.1 Añade código aqui
        # ...
        self.num_digits = num_digits
        self.base = base

    def next(self):
        # 2.2 Añade código aqui
        # ...
        inicial = [0] * self.num_digits
        repeticones = self.base ** self.num_digits
        for i in range(repeticones):
                yield inicial
                inicial = next_number(inicial, self.base)

        # Cuando no quedan valores simplemente retornamos
        return

#Orden topológico

import networkx as nx

def crear_grafo(input_list):
    grafo = nx.DiGraph()  # Grafo dirigido
    for tupla in input_list[1:]:
        u = tupla[0]
        v = tupla[1]
        grafo.add_edge(u, v)
    
    return grafo

def topological_sort(grafo, solucion, nodos_vistos, nodo):
    # Marca el nodo como visitado
    nodos_vistos.add(nodo)
    
    # Recorre todos los vecinos del nodo
    for vecino in grafo.neighbors(nodo):
        if vecino not in nodos_vistos:
            topological_sort(grafo, solucion, nodos_vistos, vecino)
    
    # Añade el nodo a la solución después de recorrer sus vecinos
    solucion.append(nodo)
    
    return solucion

if "__main__" == __name__:
    # Lista de entrada que define las aristas
    input_list = (4, (1, 2), (1, 3), (2, 4), (3, 4))
    
    # Crear el grafo
    grafo = crear_grafo(input_list)
    
    # Llamar al algoritmo de orden topológico
    resultado = topological_sort(grafo, [], set(), 1)
    
    # El orden topológico debe ser invertido al final
    resultado.reverse()
    
    # Imprimir el resultado
    print(resultado)

#Problema de las N-Reinas con Fuerza Bruta

from superanoardiente import *

def solve(num_queens):
    soluciones = []
    contador = 0
    
    iterador = My_Iterator(num_digits=4, base= num_queens)  # Cambia los valores según lo que necesites

    # Mostrar todas las combinaciones
    for numero in iterador.next():
        
        if len(set(numero)) == len(numero):
            
            if no_se_atacan(numero):
                soluciones.append(numero)
            
    return soluciones
        
def no_se_atacan(posiciones):
    """
    Verifica si las reinas en `posiciones` no se atacan en las diagonales.
    `posiciones` es una lista donde el índice representa la columna y el valor representa la fila.
    """
    for i in range(len(posiciones)):
        for j in range(i + 1, len(posiciones)):
            # Verificar si están en la misma diagonal
            if abs(i - j) == abs(posiciones[i] - posiciones[j]):
                return False
    return True


if "__main__" == __name__:
    
    num_queens = 4
    resultado = solve(num_queens)
    
    print(resultado)

#Generación de todas las combinaciones con números ya puestos

class My_Iterator:

    def __init__(self, num_digits, digit_values):
        # 2.1 Añade código aqui
        # ...
        self.num_digits = num_digits
        self.digit_values = digit_values

    def next(self):
        # 2.2 Añade código aqui
        # ...
        inicial = [values[0] for values in self.digit_values]
        
        repeticiones = 1
        for i in range(0, len(self.digit_values)):
            repeticiones * len(self.digit_values[i])
            
        for i in range(repeticiones):
                yield inicial
                
                 # Actualizar la combinación al siguiente valor permitido
                for i in range(self.num_digits - 1, -1, -1):  # Recorre los dígitos de derecha a izquierda
                    current_index = self.digit_values[i].index(inicial[i])  # Índice del valor actual
                    if current_index + 1 < len(self.digit_values[i]):  # Si hay más valores en el dominio
                        inicial[i] = self.digit_values[i][current_index + 1]
                        break
                    else:
                        # Reiniciar al primer valor del dominio y continuar al dígito anterior
                        inicial[i] = self.digit_values[i][0]

        # Cuando no quedan valores simplemente retornamos
        return

#Problema del cargador

def solve(input_list, voltaje):
    solutions_list = []
    
    def cargador_gotyx(current_voltaje, tupla, taken, voltajes_vistos):
        
        if current_voltaje == voltaje:
            if len(solutions_list) == 0:
                solutions_list.append(list(taken))
            if len(taken) < len(solutions_list[0]):
                solutions_list[0] = list(taken)
        
        for i in range(1, len(input_list)):
            
            tupla = (current_voltaje, input_list[i][1])
            
            if tupla in voltajes_vistos:
                continue
            
            if input_list[i][0] != current_voltaje:
                continue
            
            taken.append((current_voltaje, input_list[i][1]))
            voltajes_vistos.add((current_voltaje, input_list[i][1]))
            cargador_gotyx(input_list[i][1], tupla, taken, voltajes_vistos)
            taken.pop()
            voltajes_vistos.remove((current_voltaje, input_list[i][1]))

    cargador_gotyx(0, (), [], set())
    solutions_list = solutions_list[0]
    return solutions_list


if "__main__" == __name__:
    
    input_list = [(15, 13), (0, 3), (2, 10), (3, 4), (4, 5), (5, 8), (8, 9), (9, 13), (3, 4), (4, 6), (6, 7), (0, 5), (5, 7), (7, 9), (0, 2), (10, 13)]
    voltaje = input_list[0][1]
    resultado = solve(input_list, voltaje)
    
    print(resultado)

#Problema del submarino(Parte 2)

def solve(input_list):
    # Construir el grafo a partir del input
    graph ={}

    for line in input_list:
        u, v = line.split('-')
        if u not in graph:
            graph[u] = []
        if v not in graph:
            graph[v] = []
        graph[u].append(v)
        graph[v].append(u)

    all_paths = []
    visited = set()  # No es necesario marcar "start" como visitada
    visited2 = set()
    path = ['start']

    # Función DFS para buscar todas las rutas válidas
    def dfs(cave, visited, visited2, path, all_paths):
        # Si hemos llegado a la cueva "end", añadimos la ruta actual
        if cave == 'end':
            all_paths.append(list(path))
            return #Vuelve a la recursión anterior

        # Explorar todas las cuevas conectadas
        for neighbor in graph[cave]:
            if neighbor == 'start':  # No podemos volver a "start"
                continue

            if neighbor in visited2:  # Evitar revisitar cuevas pequeñas
                continue

            # Marcar la cueva como visitada si es pequeña
            if neighbor.islower() and neighbor in visited:
                visited2.add(neighbor)
            
            if neighbor.islower():
                visited.add(neighbor)

            path.append(neighbor)
            dfs(neighbor, visited, visited2, path, all_paths)

            # El pop se realiza para volver al nivel anterior 
            path.pop()
            if neighbor.islower() and neighbor in visited2:
                visited2.remove(neighbor)
            
            if neighbor.islower() and not neighbor not in visited2:
                visited.remove(neighbor)

     # Iniciar DFS desde la cueva "start"
    dfs('start', visited, visited2, path, all_paths) #Esta función solo salta una vez y es la que incia la función dfs!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    num_solutions = len(all_paths)
    return num_solutions, all_paths


if "__main__" == __name__:
    
    input_list = (('start-A'), ('start-b'), ('A-c'), ('A-b'), ('b-d'), ('A-end'), ('b-end'))
    cave = 'start'
    visited = set()
    path = ['start']
    all_paths = []
    resultado = solve(input_list)

    print(resultado)

#Problema del Cargador(Parte 2)

def solve(input_list, voltaje, tolerancia):
    solutions_list = []
    
    def cargador_gotyx(current_voltaje, tupla, taken, voltajes_vistos, contador):
        
        if current_voltaje == voltaje:
            if len(solutions_list) == 0:
                solutions_list.append(list(taken))
            if len(taken) < len(solutions_list[0]):
                solutions_list[0] = list(taken)
        
        for i in range(1, len(input_list)):
            
            tupla = (current_voltaje, input_list[i][1])
            
            if tupla in voltajes_vistos:
                continue
            
            for j in range(0, tolerancia + 1):
                if input_list[i][0] - j == current_voltaje:
                    contador += 1
                    break
            
            if contador != 1:
                continue
            
            contador = 0
            
            taken.append((input_list[i][0], input_list[i][1]))
            voltajes_vistos.add((input_list[i][0], input_list[i][1]))
            cargador_gotyx(input_list[i][1], tupla, taken, voltajes_vistos, contador)
            taken.pop()
            voltajes_vistos.remove((input_list[i][0], input_list[i][1]))

    cargador_gotyx(0, (), [], set(), 0)
    solutions_list = solutions_list[0]
    return solutions_list


if "__main__" == __name__:
    
    input_list = [(11, 30, 2), (0, 13), (0, 15), (0, 5), (14, 16), (17, 25), (27, 30),(15, 26), (7, 21), (18, 19), (23, 30), (20, 24)]
    voltaje = input_list[0][1]
    tolerancia = input_list[0][2]
    resultado = solve(input_list, voltaje, tolerancia)
    
    print(resultado)

#Algoritmo de 

import networkx as nx

def check_cycle(tree, new_edge):
    def ciclo(current, target, visited):
        if current == target:
            return True  # Se encontró un ciclo.
        
        visited.add(current)
        for neighbor in tree.neighbors(current):
            if neighbor not in visited:
                if ciclo(neighbor, target, visited):
                    return True
        return False

    # Verificar si el grafo contiene ambos nodos antes de buscar un ciclo
    if new_edge[0] not in tree:
        tree.add_node(new_edge[0])  # Añadir nodo al grafo si no está presente
    if new_edge[1] not in tree:
        tree.add_node(new_edge[1])  # Añadir nodo al grafo si no está presente

    return ciclo(new_edge[0], new_edge[1], set())

def solve(input_list):
    tree_edges_list = []
    input_list = input_list[1:]  # Omitir el primer elemento si es necesario (por ejemplo, el número de aristas)

    grafo = nx.Graph()

    def divide_y_venceras(input_list, grafo, tree_edges_list):
        if len(input_list) == 0:
            return 0
        
        if len(input_list) == 1:
            u, v, peso = input_list[0]
            if not check_cycle(grafo, (u, v)):
                grafo.add_edge(u, v, weight=peso)
                tree_edges_list.append((u, v, peso))
                return peso
            return 0
        
        mid = len(input_list) // 2
        left_edges = input_list[:mid]
        right_edges = input_list[mid:]
        
        left_weight = divide_y_venceras(left_edges, grafo, tree_edges_list)
        right_weight = divide_y_venceras(right_edges, grafo, tree_edges_list)
        
        return int(left_weight) + int(right_weight)
    
    divide_y_venceras(input_list, grafo, tree_edges_list)
    
    return tree_edges_list

# Entrada con formato correcto
input_data = [
    ['A', 'B', '2'],
    ['A', 'E', '14'],
    ['A', 'D', '8'],
    ['B', 'C', '19'],
    ['B', 'E', '25'],
    ['C', 'E', '17'],
    ['C', 'F', '5'],
    ['C', 'G', '9'],
    ['D', 'E', '21'],
    ['E', 'F', '13'],
    ['F', 'G', '1']
]

# Solución
tree_edges_list = solve(input_data)
print(tree_edges_list)

#Problema del cargador parte 2 (Con poda)

def solve(input_list, voltage):
    solutions_list = []
    taken = []
    min_len = 9999
    
    def podar(taken):
        if len(solutions_list) >= 1:
            if len(taken) > len(solutions_list[0]):
                return False
            elif len(taken) <= len(solutions_list[0]):
                return True
        return True
    
    def cargador_gotyx(current_voltaje, tupla, taken, voltajes_vistos):
        nonlocal min_len
        if not podar(taken):
            return
        
        if current_voltaje == voltage:
            if len(solutions_list) == 0:
                solutions_list.append(list(taken))
            if len(taken) < len(solutions_list[0]):
                solutions_list[0] = list(taken)
        
        for i in range(1, len(input_list)):
            
            tupla = (current_voltaje, input_list[i][1])
            
            if tupla in voltajes_vistos:
                continue
            
            if input_list[i][0] != current_voltaje:
                continue
            
            taken.append((current_voltaje, input_list[i][1]))
            voltajes_vistos.add((current_voltaje, input_list[i][1]))
            cargador_gotyx(input_list[i][1], tupla, taken, voltajes_vistos)
            taken.pop()
            voltajes_vistos.remove((current_voltaje, input_list[i][1]))

    cargador_gotyx(0, (), taken, set())
    solutions_list = solutions_list[0]
    return solutions_list


if "__main__" == __name__:
    
    input_list = [(15, 13), (0, 3), (2, 10), (3, 4), (4, 5), (5, 8), (8, 9), (9, 13), (3, 4), (4, 6), (6, 7), (0, 5), (5, 7), (7, 9), (0, 2), (10, 13)]
    voltaje = input_list[0][1]
    resultado = solve(input_list, voltaje)
    
    print(resultado)

#Problema del cargador hecho por Ricardo

import networkx as nx

def solve(input_list, voltage):
    solutions_list = []
    path = []
    min_len = 999999

    G = nx.DiGraph()
    G.add_edges_from([tuple(map(int, enlace)) for enlace in input_list])

    def podar(path):
        if len(solutions_list) >= 1:
            if len(path) > len(solutions_list[0]):
                return False
            elif len(path) == len(solutions_list[0]):
                return True
            elif len(path) < len(solutions_list[0]):
                return True
        return True

    def dfs(vi, visited, path):
        nonlocal min_len
        if not podar(path):
            return

        if vi == voltage:
            path_len = len(path)
            if path_len < min_len:
                solutions_list.clear()
                min_len = path_len
            if path_len == min_len:
                solutions_list.append(path.copy())
        else:
            for w in G.neighbors(vi):
                if w not in visited:
                    path.append((vi, w))
                    visited.add(w)
                    dfs(w, visited, path)
                    visited.remove(w)
                    path.pop()

    dfs(0, {0}, [])
    return solutions_list


if "__main__" == __name__:
    
    input_list = [(15, 13), (0, 3), (2, 10), (3, 4), (4, 5), (5, 8), (8, 9), (9, 13), (3, 4), (4, 6), (6, 7), (0, 5), (5, 7), (7, 9), (0, 2), (10, 13)]
    voltaje = input_list[0][1]
    resultado = solve(input_list, voltaje)
    
    print(resultado)

#Coloreado de grafos

#import minigraph as nx

def rlf_graph_coloring(graph):
    # Obtener los nodos del grafo
    nodes = set(graph.nodes())
    
    # Calcular el grado de cada nodo (número de aristas que tiene)
    node_degrees = {node: len(list(graph.neighbors(node))) for node in nodes}
    
    def get_node_degree(node):
        return node_degrees[node]

    sorted_nodes = sorted(nodes, key=get_node_degree, reverse=True)
    
    # Diccionario para almacenar los colores de los nodos
    colors = {}
    
    # Asignamos colores a los nodos
    for node in sorted_nodes:
        # Obtener los colores de los vecinos del nodo
        neighbor_colors = set()
        for neighbor in graph.neighbors(node):
            if neighbor in colors:
                neighbor_colors.add(colors[neighbor])
        
        # Encontrar el color más bajo que no está en los colores de los vecinos
        color = 0
        while color in neighbor_colors:
            color += 1
        
        # Asignamos el color al nodo
        colors[node] = color
    
    # Ordenamos el diccionario de colores por número de nodo
    sorted_dict = {k: colors[k] for k in sorted(colors)}
    
    # Devolvemos los colores de los nodos en el orden original de los nodos
    return list(sorted_dict.values())

#Encontrar camino más corto

import networkx as nx
from pruebas import *  # Importar tu clase Queue desde pruebas.py

def crear_grafo(input_list):
    grafo = nx.Graph()
    for u, v in input_list[1:]:
        grafo.add_edge(u, v)
    return grafo

def bfs_path(graph, first_node, last_node):
    queue = Queue()                # Usar tu clase Queue
    queue.enqueue([first_node])    # Inicializar la cola con el nodo inicial
    visited = set()                # Conjunto de nodos visitados
    
    while not queue.isEmpty():
        path = queue.dequeue()     # Obtener el primer camino de la cola
        node = path[-1]            # Último nodo en el camino actual
        
        if node == last_node:      # Si llegamos al destino, retornamos el camino
            return path
        
        if node not in visited:
            visited.add(node)     # Marcar el nodo como visitado
            for neighbor in graph.neighbors(node):
                new_path = list(path)  # Crear una copia del camino actual
                new_path.append(neighbor)  # Agregar el vecino al camino
                queue.enqueue([new_path])    # Agregar el nuevo camino a la cola
    
    return None  # Si no hay camino entre los nodos

if "__main__" == __name__:
    input_list = ((6, 7), (1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (5, 4), (4, 6))
    graph = crear_grafo(input_list)
    resultado = bfs_path(graph, 1, 6)
    print(resultado)

#Componentes conectados con la pila

import networkx as nx

class Stack:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return len(self.items) == 0

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def peek(self):
        return self.items[-1]

    def size(self):
        return len(self.items)

def dfs(input_list):
    # Crear el grafo
    grafo = nx.Graph()

    def crear_grafo(input_list):
        for tupla in input_list:
            grafo.add_edge(tupla[0], tupla[1])

    def encontrar_componentes(grafo):
        pila = Stack()
        visited = set()
        componentes = []  # Lista para guardar las componentes conexas

        for node in grafo.nodes():
            if node not in visited:
                componente = []  # Nueva componente conexa
                pila.push(node)

                while not pila.isEmpty():
                    current_node = pila.pop()

                    if current_node not in visited:
                        visited.add(current_node)
                        componente.append(current_node)

                        for vecino in grafo.neighbors(current_node):
                            if vecino not in visited:
                                pila.push(vecino)

                # Agregar la componente encontrada a la lista de componentes
                componentes.append(componente)

        return sorted(componentes, key=len)

    # Construir y recorrer el grafo
    crear_grafo(input_list)
    return encontrar_componentes(grafo)

if __name__ == "__main__":
    input_list = [(4, 3), (5, 6), (6, 2), (1, 1)]  # Lista de aristas
    resultado = dfs(input_list)
    print("Componentes conexas:", resultado)

#Problema de saber cuál es el numero que se repite en el array(Divide y Vencerás)

def repetidos(lista, left, right):
    if left == right:
        return [lista[left]]
    
    medio = (left + right) // 2
    
    elemento_izq = repetidos(lista, left, medio) # [1]
    elemento_der = repetidos(lista, medio + 1, right) # [2]
    
    def is_repetic(n):
        contador = 0
        for j in range(0, len(n)):
            for i in range(0, len(lista)):
                if lista[i] == n[j]:
                    contador += 1
            if contador > 1:
                return [n[j]]
            
            contador = 0
        
        return False

    if is_repetic(elemento_izq) != False:
        return is_repetic(elemento_izq)
    
    if is_repetic(elemento_der) != False:
        return is_repetic(elemento_der)

    return elemento_izq + elemento_der


if "__main__" == __name__:
    
    lista = [1, 2, 4, 4, 5]
    resultado = repetidos(lista, 0, len(lista) - 1)
    
    print(f"El elemento que se repite es el: {resultado[0]}")

#Distancia mínima grafo dirigido(Memorization)

def solve(graph, from_node, to_node):
    # Memoization dictionary to store the minimum distance to each node
    memo = {}
    
    # Dictionary to reconstruct the path
    predecessor = {}

    def dp(v):
        # If we've already computed the distance to node v, return it
        if v in memo:
            return memo[v]

        # Base case: if v is the source node, distance is 0
        if v == from_node:
            memo[v] = 0
            return 0

        # Get all incoming edges to v
        incoming_edges = graph.in_edges(v, data=True)

        # If there are no incoming edges (v is disconnected), return infinity
        if not incoming_edges:
            memo[v] = float('inf')
            return float('inf')

        # Recurrence: find the minimum distance
        min_dist = float('inf')
        for u, _, data in incoming_edges:
            weight = data['weight']
            dist_u = dp(u) # 4
            if dist_u + weight < min_dist: # 5
                min_dist = dist_u + weight
                predecessor[v] = u

        # Store the result in memo and return it
        memo[v] = min_dist
        return min_dist

    # Compute the shortest distance to the target node
    min_distance = dp(to_node)

    # Reconstruct the path by backtracking from the target node
    path = []
    current = to_node
    while current in predecessor:
        path.append(current)
        current = predecessor[current]
    path.append(from_node)
    path.reverse()

    return min_distance, path

# Example usage:
# Given the graph from the image and inputs from_node=7, to_node=8,
# the code will calculate the shortest path and its distance.

#Problema de encontrar todas las inversiones de un array(Divide y Vencerás)

def inver(lista, left, rigth):
    
    if left == rigth:
        return [lista[left]], 0
    
    medio = (left + rigth) // 2
    
    elemento_izq, inversiones_izq = inver(lista, left, medio) # [2]
    elemento_der, inversiones_der = inver(lista, medio + 1, rigth) # [4]
    
    listilla, numero_inversiones = contar_inversiones(elemento_izq, elemento_der)
    
    return listilla, len(numero_inversiones)

def contar_inversiones(n, m):
    listilla = n + m
    inversiones = []
    
    for i in range(0, len(listilla) - 1):
        for j in range(1, len(listilla)):
            if listilla[i] > listilla[j] and j > i:
                if (listilla[i], listilla[j]) not in inversiones:
                    inversiones.append((listilla[i], listilla[j]))
    
    return listilla, inversiones


if "__main__" == __name__:
    
    lista = [2, 4, 1, 3, 5]
    resultado = inver(lista, 0, len(lista) - 1)
    
    print(f"El número total de inversiones son: {resultado[1]}")

#Ejercicio de ecuación de recurrencia con memorization

def solve(p, q):
    # Diccionario para almacenar los resultados de subproblemas
    memoria = {}

    def memo(p, q):
        # Caso base: si p == q, la función devuelve 1
        if p == q:
            return 1

        # Si el resultado ya está calculado, devuélvelo
        if (p, q) in memoria:
            return memoria[(p, q)]

        # Primera parte de la ecuación: t(p+1, q)
        primera_parte_ecuacion = memo(p + 1, q)

        # Segunda parte de la ecuación: suma de t(p, k) + t(k+1, q) para k = p hasta q-1
        suma = 0
        for k in range(p, q):
            suma += memo(p, k) + memo(k + 1, q)

        # Calcular el máximo entre ambas partes
        resultado_ecuacion = max(primera_parte_ecuacion, suma)

        # Almacenar el resultado en la memoria
        memoria[(p, q)] = resultado_ecuacion
        return resultado_ecuacion

    # Llamar a la función memo para calcular t(p, q)
    return memo(p, q)

#Algoritmo partition con Divide y Vencerás

def partition(items, left_pos, right_pos):
    # Elegir el pivote como el elemento más a la izquierda
    pivote = items[left_pos]
    
    # Inicializar punteros
    i = left_pos + 1  # Puntero que busca elementos mayores que el pivote
    j = right_pos     # Puntero que busca elementos menores que el pivote
    
    while True:
        # Mover el puntero `i` hacia la derecha mientras los elementos sean menores o iguales al pivote
        while i <= j and items[i] <= pivote:
            i += 1
        
        # Mover el puntero `j` hacia la izquierda mientras los elementos sean mayores al pivote
        while i <= j and items[j] > pivote:
            j -= 1
        
        # Si los punteros se cruzan, romper el bucle
        if i > j:
            break
        
        # Intercambiar elementos en las posiciones `i` y `j`
        items[i], items[j] = items[j], items[i]
    
    # Colocar el pivote en su posición definitiva (intercambiarlo con `items[j]`)
    items[left_pos], items[j] = items[j], items[left_pos]
    
    # Retornar la posición final del pivote
    return j


if "__main__" == __name__:
    
    items = [20, 30, 10]
    resultado = partition(items, 0, len(items) - 1)

    print(resultado)

#Coloreado de grafo más breve

import networkx as nx

def crear_grafo(input_list):
    grafo = nx.Graph()
    for tupla in input_list[1:]:
        grafo.add_edge(tupla[0], tupla[1])
    return grafo

def coloreado(grafo):
    # Conjunto de nodos del grafo
    nodes = set(grafo.nodes())
    colors = {}  # Diccionario de colores asignados a cada nodo
    
    # Función que calcula el grado de un nodo (número de vecinos)
    def grado_nodos(nodo):
        n = list(grafo.neighbors(nodo))
        return len(n)
    
    # Ordenar los nodos por su grado en orden descendente
    nodos_ordenados = sorted(nodes, key=grado_nodos, reverse=True)
    
    # Asignar colores a los nodos
    for node in nodos_ordenados:
        # Crear un conjunto de vecinos del nodo
        vecinos = set(grafo.neighbors(node))
        
        # Encontrar el primer color que no esté en los vecinos
        color = 0
        while color in colors.values() and any(colors.get(vecino) == color for vecino in vecinos):
            color += 1  # Incrementar color hasta encontrar uno disponible
        
        # Asignar el color encontrado al nodo
        colors[node] = color
    
    return colors

if "__main__" == __name__:
    input_list = ((7, 12), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 7), (2, 7), (3, 7), (4, 7), (5, 7), (6, 7), (1, 6))
    grafo = crear_grafo(input_list)
    resultado = coloreado(grafo)
    print(resultado)

#Coloreado de grafos super entendible(dominar tuplas, conjuntos, listas comprenhension)

import networkx as nx

def crear_grafo(input_list):
    grafo = nx.Graph()
    for tupla in input_list[1:]:
        grafo.add_edge(tupla[0], tupla[1])
    return grafo

def coloreado(grafo):
    # Conjunto de nodos del grafo
    nodes = set(grafo.nodes())
    colors = {}  # Diccionario de colores asignados a cada nodo

    # Función que calcula el grado de un nodo (número de vecinos)
    def grado_nodos(nodo):
        return len(list(grafo.neighbors(nodo)))

    # Ordenar los nodos por su grado en orden descendente
    nodos_ordenados = sorted(nodes, key=grado_nodos, reverse=True)

    # Definir color_vecinos ANTES del bucle
    def color_vecinos(nodo):
        color = 0
        # Obtener los colores usados por los vecinos
        vecinos_colors = {colors[vecino] for vecino in grafo.neighbors(nodo) if vecino in colors}
        
        # Encontrar el primer color disponible
        while color in vecinos_colors:
            color += 1
        
        return color

    # Asignar colores a los nodos
    for node in nodos_ordenados:
        colors[node] = color_vecinos(node)

    return colors
        
    
if "__main__" == __name__:
    input_list = ((7, 12), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 7), (2, 7), (3, 7), (4, 7), (5, 7), (6, 7), (1, 6))
    grafo = crear_grafo(input_list)
    resultado = coloreado(grafo)
    print(resultado)

#House Robber memorization

def solve(casas):
    # Diccionario para almacenar resultados de subproblemas
    memoria = {}

    # Función recursiva con memoización
    def memo(v):
        # Caso base: si no hay casas restantes
        if v < 0:
            return 0

        # Si ya hemos calculado este subproblema, lo devolvemos
        if v in memoria:
            return memoria[v]

        # Decidir entre robar la casa actual o no robarla
        robar = casas[v] + memo(v - 2)  # Robar la casa actual, saltando una
        no_robar = memo(v - 1)         # No robar la casa actual

        # Guardar el resultado en la memoria
        memoria[v] = max(robar, no_robar)
        return memoria[v]

    # Llamar a la función recursiva empezando desde la última casa
    return memo(len(casas) - 1)

#Divide y vencerás bastante más entendible

def solve(input_list):
    indices_equilibrados = []

    def divideme_esta(start, end):
        # Caso base: un solo elemento
        if start == end:
            if equilibrio(start):
                indices_equilibrados.append(start)
            return
        
        # Dividir el arreglo en dos mitades
        medio = (start + end) // 2
        
        # Resolver para la mitad izquierda
        divideme_esta(start, medio)
        
        # Resolver para la mitad derecha
        divideme_esta(medio + 1, end)

    def equilibrio(indice):
        # Calcular suma izquierda
        suma_izquierda = sum(input_list[:indice])
        
        # Calcular suma derecha
        suma_derecha = sum(input_list[indice + 1:])
        
        # Verificar equilibrio
        return suma_izquierda == suma_derecha

    # Llamada inicial a la función recursiva
    divideme_esta(0, len(input_list) - 1)
    
    return indices_equilibrados


if __name__ == "__main__":
    nums = [1, 7, 3, 6, 5, 6]
    resultado = solve(nums)
    print(resultado)

#Mochila con memorization

def memorization(objetos, peso):
    memoria = {}
    
    def memo(n, peso_restante):
        # Casos base: Si no hay objetos o no hay capacidad en la mochila
        if n < 0 or peso_restante == 0:
            return 0
        
        # Verificar si ya hemos calculado el resultado
        if (n, peso_restante) in memoria:
            return memoria[(n, peso_restante)]
        
        # No coger el objeto n
        no_coger_objeto = memo(n - 1, peso_restante)
        
        # Coger el objeto n (si cabe en la mochila)
        if objetos[n][0] <= peso_restante:
            coger_objeto = objetos[n][1] + memo(n - 1, peso_restante - objetos[n][0])
        else:
            coger_objeto = 0
        
        # Tomamos el máximo entre coger o no coger el objeto
        maximo_valor = max(coger_objeto, no_coger_objeto)
        
        # Guardamos el valor calculado en la memoria
        memoria[(n, peso_restante)] = maximo_valor
        
        return maximo_valor
    
    return memo(len(objetos) - 1, peso)

if "__main__" == __name__:
    w = 5
    objetos = [(1, 1), (2, 2), (3, 3)]  # (peso, valor)
    resultado = memorization(objetos, w)
    print(resultado)

#Kruskal pero con divide y vencerás más entendible

import networkx as nx

def check_cycle(tree, new_edge):
    def ciclo(current, target, visited):
        if current == target:
            return True  # Se encontró un ciclo.
        
        visited.add(current)
        for neighbor in tree.neighbors(current):
            if neighbor not in visited:
                if ciclo(neighbor, target, visited):
                    return True
        return False

    # Verificar si el grafo contiene ambos nodos antes de buscar un ciclo
    if new_edge[0] not in tree:
        tree.add_node(new_edge[0])  # Añadir nodo al grafo si no está presente
    if new_edge[1] not in tree:
        tree.add_node(new_edge[1])  # Añadir nodo al grafo si no está presente

    return ciclo(new_edge[0], new_edge[1], set())

def solve(input_list):
    tree_edges_list = []
    input_list = input_list[1:]  # Omitir el primer elemento si es necesario (por ejemplo, el número de aristas)

    grafo = nx.Graph()

    def divide_y_venceras(start, end):
        if start > end == 0:
            return 0
        
        if start == end:
            u, v, peso = input_list[start]
            if not check_cycle(grafo, (u, v)):
                grafo.add_edge(u, v, weight=peso)
                tree_edges_list.append((u, v, int(peso)))
                return peso
            return 0
        
        medio = (start + end) // 2
        divide_y_venceras(start, medio)
        divide_y_venceras(medio + 1, end)
    
    divide_y_venceras(0, len(input_list) - 1)
    
    return tree_edges_list

# Entrada con formato correcto
input_data = [
    ['A', 'B', '2'],
    ['A', 'E', '14'],
    ['A', 'D', '8'],
    ['B', 'C', '19'],
    ['B', 'E', '25'],
    ['C', 'E', '17'],
    ['C', 'F', '5'],
    ['C', 'G', '9'],
    ['D', 'E', '21'],
    ['E', 'F', '13'],
    ['F', 'G', '1']
]

# Solución
tree_edges_list = solve(input_data)
print(tree_edges_list)

#Orden topológico hecho de una manera más fácil

import networkx as nx

def next_number(digits, base):
    # ...
    next_digits = digits.copy()

    # Añade tu código aqui
    # ...
    carry = 1
    for i in range(len(next_digits)-1,-1,-1):
        next_digits[i] = next_digits[i] + carry
        if next_digits[i] == base:
            next_digits[i] = 0
        else:
            carry = 0
            break


    return next_digits
#----------------------------------------------------------
class My_Iterator:

    def __init__(self, num_digits, base):
        # 2.1 Añade código aqui
        # ...
        self.num_digits = num_digits
        self.base = base

    def next(self):
        # 2.2 Añade código aqui
        # ...
        inicial = [0] * self.num_digits
        repeticones = self.base ** self.num_digits
        for i in range(repeticones):
                yield inicial
                inicial = next_number(inicial, self.base)

        # Cuando no quedan valores simplemente retornamos
        return

def solve(input_list):
    solutions_list = []

    def crear_grafo(input_list):
        grafo = nx.DiGraph()  # Grafo dirigido
        for tupla in input_list[1:]:
            u = tupla[0]
            v = tupla[1]
            grafo.add_edge(u, v)
        
        return grafo
    
    grafo = crear_grafo(input_list)
    n = len(list(grafo.nodes()))
    
    def combinaciones(num, bas):
        
        iterador = My_Iterator(num_digits=num, base=bas)
        
        for numero in iterador.next():
            if len(numero) == len(set(numero)):
                if topologico(numero):
                    solutions_list.append(numero)
        
        return solutions_list
    
    def topologico(n):
        for node in n:
            p = grafo.in_edges(node)
            for element in p:
                if n.index(element[1]) < n.index(element[0]):
                    return False
        
        return True
    
    combinaciones(n, n)
    return solutions_list


if "__main__" == __name__:
    
    input_list = (4, (0, 2), (1, 2), (2, 3), (2, 4))
    resultado = solve(input_list)
    
    print(resultado)

#Mochila con fuerza bruta y enumerate() que es una función muy útil, la explicación de lo que hace está en la carpeta Backtracking esta loco

import networkx as nx

def next_number(digits, base):
    # ...
    next_digits = digits.copy()

    # Añade tu código aqui
    # ...
    carry = 1
    for i in range(len(next_digits)-1,-1,-1):
        next_digits[i] = next_digits[i] + carry
        if next_digits[i] == base:
            next_digits[i] = 0
        else:
            carry = 0
            break


    return next_digits
#----------------------------------------------------------
class My_Iterator:

    def __init__(self, num_digits, base):
        # 2.1 Añade código aqui
        # ...
        self.num_digits = num_digits
        self.base = base

    def next(self):
        # 2.2 Añade código aqui
        # ...
        inicial = [0] * self.num_digits
        repeticones = self.base ** self.num_digits
        for i in range(repeticones):
                yield inicial
                inicial = next_number(inicial, self.base)

        # Cuando no quedan valores simplemente retornamos
        return

def solve(capacity, input_list):
    best_value = 0
    solution = []
    pesos = []
    valores = []
    
    for element in input_list[1:]:
        valores.append(element[0])
        pesos.append(element[1])
    
    iterador = My_Iterator(num_digits=len(pesos), base=2)
    
    for numero in iterador.next():
        indice_opcion = [i for i, v in enumerate(numero) if v == 1]
        peso_opcion = [pesos[i] for i in indice_opcion]
        
        if sum(peso_opcion) <= capacity:
            
            indice_valor = [i + 1 for i, v in enumerate(numero) if v == 1]
            valor_opcion = [valores[i - 1] for i in indice_valor]
            
            if sum(valor_opcion) > best_value:
                solution = indice_valor
                best_value = sum(valor_opcion)
    
    return(solution, best_value)


if "__main__" == __name__:
    
    input_list = ((4, 11), (8, 4), (10, 5), (15, 8), (4, 3))
    capacidad = input_list[0][1]
    resultado = solve(capacidad, input_list)
    
    print(resultado)

#Cambio de monedas con Greedy

def cambio(monedas, change):
    
    total_monedas = 0
    
    while len(monedas) != 0:
        moneda_maxima = max([moneda for moneda in monedas])
        
        if total_monedas + moneda_maxima > change:
            monedas_borrar = [i for i, v in enumerate(monedas) if v == moneda_maxima]
            monedas = [monedas[i] for i, v in enumerate(monedas) if i not in monedas_borrar]
        elif total_monedas + moneda_maxima <= change:
            total_monedas += moneda_maxima

    return total_monedas


if "__main__" == __name__:
    
    change = 12
    monedas = [5, 2, 1, 10, 10, 2]
    resultado = cambio(monedas, change)
    
    print(resultado)

#Problema conseguir máxima energía con Memorization

def solve(energia):
    n = len(energia)  # Número de niveles
    memoria = {}

    def memo(v):
        # Si estamos fuera de los límites, no es una ruta válida
        if v >= n:
            return -9999  # Valor negativo arbitrario (imposible ganar)
        
        # Si estamos en el último nivel, devolvemos su energía
        if v == n - 1:
            return energia[v]
        
        # Si ya hemos calculado este nivel, lo reutilizamos
        if v in memoria:
            return memoria[v]
        
        # Saltar un nivel o dos niveles
        saltar_un_nivel = energia[v] + memo(v + 1)
        saltar_dos_niveles = energia[v] + memo(v + 2)
        
        # Elegimos la máxima energía posible
        maxima_energia = max(saltar_un_nivel, saltar_dos_niveles)
        
        # Guardamos en la memoria
        memoria[v] = maxima_energia
        return maxima_energia

    # Resolver desde el nivel 0
    resultado = memo(0)
    
    # Si el resultado es negativo, no es posible ganar
    return resultado if resultado >= 0 else -1


if "__main__" == __name__:
    lista = [1, -2, 3, 5, -3, 2]
    resultado = solve(lista)
    print(resultado)  # Resultado esperado: 9

#Problema suma perfecta con Memorization

def solve(numeros, target):
    memoria = {}
    resultados = []

    def memo(v, idx, actual):
        # Caso base: si llegamos exactamente al objetivo
        if v == 0:
            resultados.append(actual[:])  # Agregamos una copia del subconjunto actual
            return 1

        # Caso base: si el objetivo es negativo o no quedan más números
        if v < 0 or idx >= len(numeros):
            return 0

        # Si ya hemos calculado para este estado
        if (v, idx) in memoria:
            return memoria[(v, idx)]

        # Opción 1: incluir el número actual
        actual.append(numeros[idx])
        incluir = memo(v - numeros[idx], idx + 1, actual)
        actual.pop()  # Backtracking

        # Opción 2: no incluir el número actual
        no_incluir = memo(v, idx + 1, actual)

        # Almacenar en memoria y retornar la suma de ambas opciones
        memoria[(v, idx)] = incluir + no_incluir
        return memoria[(v, idx)]

    memo(target, 0, [])
    return resultados


if "__main__" == __name__:
    
    nums = [1, 2, 3, 4]
    target = 5
    print(solve(nums, target))

#Mochila con Memorization

def solve(pesos, valores, capacidad):
    memoria = {}

    def memo(v, indice):
        # Si hemos recorrido todos los objetos o excedemos la capacidad
        if v > capacidad or indice >= len(pesos):
            return 0

        # Si ya hemos calculado este estado
        if (v, indice) in memoria:
            return memoria[(v, indice)]

        # Opción 1: No incluir el objeto actual
        no_incluir = memo(v, indice + 1)

        # Opción 2: Incluir el objeto actual (si cabe)
        incluir = 0
        if v + pesos[indice] <= capacidad:
            incluir = valores[indice] + memo(v + pesos[indice], indice + 1)

        # Guardar el mejor resultado en memoria
        memoria[(v, indice)] = max(incluir, no_incluir)
        return memoria[(v, indice)]

    return memo(0, 0)


if __name__ == "__main__":
    pesos = [1, 2, 3]
    valores = [6, 10, 12]
    capacidad = 5
    print(solve(pesos, valores, capacidad))

#Combinaciones de elementos que dan la suma de S con memorization

def solve(lista, S):
    memoria = {}
    listilla = []

    def memo(S, indice, lista_de_suma):
        # Casos base
        if S == 0:
            listilla.append(list(lista_de_suma))
            return 1  # Si hemos alcanzado la suma exacta
        if indice >= len(lista) or S < 0:
            return 0  # Si no quedan elementos o la suma es negativa

        # Usar la memoria si ya calculamos este subproblema
        if (S, indice) in memoria:
            return memoria[(S, indice)]

        # Decidir no coger el elemento actual
        no_coger = memo(S, indice + 1, lista_de_suma)

        # Decidir coger el elemento actual (hacer copia de la lista)
        lista_con_elemento = lista_de_suma + [lista[indice]]
        coger = memo(S - lista[indice], indice + 1, lista_con_elemento)

        # Guardar el resultado en la memoria
        memoria[(S, indice)] = max(no_coger, coger)

        return memoria[(S, indice)]

    memo(S, 0, [])
    # Llamar a la función recursiva
    return listilla  # Devuelve True si es posible alcanzar la suma

lista = [2, 3, 8, 7, 4]
S = 11
print(solve(lista, S))

#Problema de la mochila con Memorization (más entendible)

def solve(pesos, valores, capacidad):
    memoria = {}
    lista_objetos = []
    valor_maximo = 0
    
    def memo(capacidad_restante, indice, lista_elementos, valor_actual):
        # Casos base: Si la capacidad se excede o si no quedan objetos
        if capacidad_restante <= 0 or indice >= len(pesos):
            # Si hemos encontrado una mejor solución, actualizamos
            nonlocal valor_maximo, lista_objetos
            if valor_actual > valor_maximo:
                valor_maximo = valor_actual
                lista_objetos = list(lista_elementos)  # Copiar la lista actual
            return valor_actual
        
        # Comprobamos si ya hemos resuelto este subproblema
        if (capacidad_restante, indice) in memoria:
            return memoria[(capacidad_restante, indice)]

        # No coger el elemento actual
        no_coger = memo(capacidad_restante, indice + 1, lista_elementos, valor_actual)

        # Coger el elemento actual, solo si cabe en la mochila
        coger = 0
        if capacidad_restante >= pesos[indice]:
            lista_elementos.append(indice)  # Añadir el índice del objeto
            coger = memo(capacidad_restante - pesos[indice], indice + 1, lista_elementos, valor_actual + valores[indice])
            lista_elementos.pop()  # Deshacer la selección

        # Guardar el mejor resultado de las dos opciones
        memoria[(capacidad_restante, indice)] = max(no_coger, coger)

        return memoria[(capacidad_restante, indice)]
    
    # Llamar a la función recursiva
    memo(capacidad, 0, [], 0)

    return lista_objetos, valor_maximo


# Ejemplo de uso
if __name__ == "__main__":
    pesos = [1, 2, 3]
    valores = [6, 10, 12]
    capacidad = 5
    print(solve(pesos, valores, capacidad))  # Debería devolver la lista de objetos y el valor máximo

#Problema del cargador hecho a mi manera

import networkx as nx

def solve(input_list, voltage):
    
    solution_list = []
    min_len = 9999
    G = nx.DiGraph()
    G.add_edges_from([tuple(map(int, enlace.split())) for enlace in input_list])
    
    def podar(path):
        if len(solution_list) >= 1:
            if len(path) > len(solution_list[0]):
                return False
            elif len(path) == len(solution_list[0]):
                return True
            elif len(path) < len(solution_list[0]):
                return True

        return True
    
    def dfs(current_voltaje, taken, visited):
        nonlocal min_len
        if not podar(taken):
            return
        
        if current_voltaje == voltage:
            taken_len = len(taken)
            if taken_len < min_len:
                solution_list.clear()
                min_len = taken_len
            if taken_len == min_len:
                solution_list.append(taken.copy())

            return
        
        for vecino in G.neighbors(current_voltaje):
            
            if vecino in visited:
                continue
            
            taken.append((current_voltaje, vecino))
            visited.add(vecino)
            dfs(vecino, taken, visited)
            taken.pop()
            visited.remove(vecino)
        
        return solution_list
    
    resultado =  dfs(0, [], set()) 

    return resultado


if "__main__" == __name__:
    
    input_list = ["15 13", "0 3", "2 10", "3 4", "4 5", "5 8", "8 9", "9 13", "3 4", "4 6", "6 7", "0 5", "5 7", "7 9", "0 2", "10 13"]
    voltage = 13
    resultado = solve(input_list, voltage)
    
    print(resultado)

#Problema House Robber bastante más entendible

def solve(casas):
    memoria = {}
    
    def memo(indice):
        # Si hemos recorrido todas las casas, no hay más valor que ganar
        if indice >= len(casas):
            return 0, []
        
        # Si el valor para este índice ya está memorizado, lo devolvemos
        if indice in memoria:
            return memoria[indice]
        
        # Caso cuando no cogemos la casa actual
        no_coger, camino_sin_casa = memo(indice + 1)
        
        # Caso cuando cogemos la casa actual (salto dos casas)
        coger, camino_con_casa = memo(indice + 2)
        
        # Comparamos ambos casos y decidimos el mejor camino
        if casas[indice] + coger > no_coger:
            camino = [casas[indice]] + camino_con_casa
            max_valor = casas[indice] + coger
        else:
            camino = camino_sin_casa
            max_valor = no_coger
        
        # Guardamos el resultado en la memorización
        memoria[indice] = max_valor, camino
        return memoria[indice]
    
    # Llamada inicial a la función memo desde el índice 0
    return memo(0)

#Shortest distance con Memorization

import networkx as nx

def solve(input_list, from_node, to_node):
    memoria = {}
    
    grafo = nx.DiGraph()
    
    # Función para crear el grafo
    def crear_grafo(input_list):
        for tupla in input_list:
            grafo.add_edge(tupla[0], tupla[1], peso=tupla[2])
        return grafo
    
    grafo = crear_grafo(input_list)
    
    # Función de memorización
    def memo(n):
        # Caso base: Si hemos llegado al nodo de inicio, la distancia es 0 y no hay camino
        if n == from_node:
            return 0, [n]
        
        # Si ya hemos calculado la distancia y el camino para este nodo, lo devolvemos
        if n in memoria:
            return memoria[n]
        
        min_distance = float('inf')
        mejor_camino = []

        # Recorremos los predecesores del nodo actual
        for p in grafo.predecessors(n):
            peso = grafo[p][n]['peso']  # Accedemos al peso de la arista entre p y n
            dist_u, camino = memo(p)
            
            # Actualizamos si encontramos una mejor ruta
            if dist_u + peso < min_distance:
                min_distance = dist_u + peso
                mejor_camino = camino + [n]
        
        # Guardamos el resultado en la memoria para el nodo actual
        memoria[n] = (min_distance, mejor_camino)
        return memoria[n]
    
    # Llamamos a la función memo para obtener la distancia mínima y el camino
    return memo(to_node)

if __name__ == "__main__":
    input_list = [
        (7, 1, 1), (7, 3, 2), (7, 5, 5), 
        (1, 2, 4), (1, 4, 3), (3, 2, 9), 
        (3, 4, 5), (3, 6, 16), (5, 6, 22), 
        (2, 8, 18), (4, 8, 13), (6, 8, 2)
    ]
    resultado = solve(input_list, 7, 8)
    print("Distancia mínima y camino:", resultado)

#Problema del House Robber hecho con memorization

def solve(casas):
    
    memoria = {}
    
    def memo(indice):
        
        if indice >= len(casas):
            return 0, []
        
        if indice in memoria:
            return memoria[indice]
        
        no_coger, camino_no_coger = memo(indice + 1)
        coger, camino_coger = memo(indice + 2)
        
        if coger + casas[indice] > no_coger:
            
            mejor_camino = [casas[indice]] + camino_coger
            maximo_valor = coger + casas[indice]
        else:
            
            mejor_camino = camino_no_coger
            maximo_valor = no_coger
        
        memoria[indice] = maximo_valor, mejor_camino
        return memoria[indice]
    
    return memo(0)


if "__main__" == __name__:
    
    casas = [3, 10, 3, 1, 2]
    resultado = solve(casas)
    
    print(resultado)

#Problema de la mochila hecha con Memorization(Más entendible)

def solve(pesos, valores, capacidad):
    
    memoria = {}
    
    def memo(indice, peso_actual):
        
        if indice >= len(pesos):
            return 0, peso_actual, []
        
        if (indice, peso_actual) in memoria:
            return memoria[(indice, peso_actual)]
        
        no_coger, peso_no_cogido, camino_no_coger = memo(indice + 1, peso_actual)

        coger = 0
        peso_cogido = peso_actual
        camino_coger = []
        
        if peso_actual + pesos[indice] <= capacidad:
            coger, peso_cogido, camino_coger = memo(indice + 1, peso_actual + pesos[indice])
            coger += valores[indice]
            camino_coger = camino_coger + [indice]
            
        if coger > no_coger:
            maximo_valor = coger
            mejor_peso = peso_cogido
            mejor_camino = camino_coger
        else:
            maximo_valor = no_coger
            mejor_peso = peso_no_cogido
            mejor_camino = camino_no_coger
            
        memoria[(indice, peso_actual)] = maximo_valor, mejor_peso, mejor_camino
        return memoria[(indice, peso_actual)]
    
    resultado = memo(0, 0)
    return f"El valor máximo es: {resultado[0]}, el peso es {resultado[1]} y los objetos cogidos son: {resultado[2]}"


if "__main__" == __name__:

    valores = [8, 10, 9]
    pesos = [4, 5, 7]
    capacidad = 11
    resultado = solve(pesos, valores, capacidad)
    
    print(resultado)

#Mirar errores muy interesantes memorization

def solve(pesos, valores, capacidad):
    
    memoria = {}
    
    def memo(indice, peso_actual):
        
        if indice >= len(pesos):
            return 0, peso_actual, []
        
        if (indice, peso_actual) in memoria:
            return memoria[(indice, peso_actual)]
        
        no_coger, peso_no_cogido, camino_no_coger = memo(indice + 1, peso_actual)

        coger = 0
        peso_cogido = peso_actual #Estas 3 variables se ponen así ya que si no se cumple la condición de abajo no se crean, así que las debes crear tú en caso de que no se ejecute la condición de abajo
        camino_coger = []
        
        if peso_actual + pesos[indice] <= capacidad:
            
            coger, peso_cogido, camino_coger = memo(indice + 1, peso_actual + pesos[indice]) #Esto no suma a los valores de peso_actual
            
        if coger > no_coger:
            maximo_valor = coger + valores[indice]
            mejor_peso = peso_cogido + pesos[indice]  #Estas 3 líneas están mal porque estás sumando los valores después de una condición que nunca se cumplirá porque sumas dentro de ella
            mejor_camino = camino_coger + [indice]
        else:
            maximo_valor = no_coger
            mejor_peso = peso_no_cogido
            mejor_camino = camino_no_coger
            
        memoria[(indice, peso_actual)] = maximo_valor, mejor_peso, mejor_camino
        return memoria[(indice, peso_actual)]
    
    resultado = memo(0, 0)
    return f"El valor máximo es: {resultado[0]}, el peso es {resultado[1]} y los objetos cogidos son: {resultado[2]}"


if "__main__" == __name__:

    valores = [8, 10, 9]
    pesos = [4, 5, 7]
    capacidad = 11
    resultado = solve(pesos, valores, capacidad)
    
    print(resultado)

#Ejercicio de la mochila hecho a mi manera

def solve(pesos, valores, capacidad):
    
    solutions_list = []
    valor_maximo = -9999
    
    def poda(n):
        if n > valor_maximo:
            return True
        elif n <= valor_maximo:
            return False
    
    def dfs(taken, objetos_cogidos, indice_actual, peso_actual, valor_actual):
        nonlocal valor_maximo
        if not poda(valor_actual):
            return
        
        if indice_actual == len(pesos):
            if valor_actual > valor_maximo:
                valor_maximo = valor_actual
                solutions_list.clear()
                solutions_list.append((valor_actual, list(taken)))
            
            return
        
        for i in range(0, len(pesos)):
            
            if i in objetos_cogidos:
                continue
            
            if peso_actual + pesos[i] > capacidad:
                objetos_cogidos.add(i)
                dfs(taken, objetos_cogidos, indice_actual + 1, peso_actual, valor_actual)
                objetos_cogidos.remove(i)
                return
            
            taken.append(i)
            objetos_cogidos.add(i)
            dfs(taken, objetos_cogidos, indice_actual + 1, peso_actual + pesos[i], valor_actual + valores[i])
            taken.pop()
            objetos_cogidos.remove(i)
        
        return solutions_list
    
    dfs([], set(), 0, 0, 0)
            
    return solutions_list


if __name__ == "__main__":
    pesos = [5, 1, 2, 3]
    valores = [13, 6, 7, 12]
    peso_maximo = 8
    resultado = solve(pesos, valores, peso_maximo)
    
    print(resultado)

#Topological sort hecho con predecessors y sucessors

import networkx as nx

def next_number(digits, base):
    # ...
    next_digits = digits.copy()

    # Añade tu código aqui
    # ...
    carry = 1
    for i in range(len(next_digits)-1,-1,-1):
        next_digits[i] = next_digits[i] + carry
        if next_digits[i] == base:
            next_digits[i] = 0
        else:
            carry = 0
            break


    return next_digits
#----------------------------------------------------------
class My_Iterator:

    def __init__(self, num_digits, base):
        # 2.1 Añade código aqui
        # ...
        self.num_digits = num_digits
        self.base = base

    def next(self):
        # 2.2 Añade código aqui
        # ...
        inicial = [0] * self.num_digits
        repeticones = self.base ** self.num_digits
        for i in range(repeticones):
                yield inicial
                inicial = next_number(inicial, self.base)

        # Cuando no quedan valores simplemente retornamos
        return

def solve(input_list):
    solutions_list = []

    def crear_grafo(input_list):
        grafo = nx.DiGraph()  # Grafo dirigido
        for tupla in input_list[1:]:
            u = tupla[0]
            v = tupla[1]
            grafo.add_edge(u, v)
        
        return grafo
    
    grafo = crear_grafo(input_list)
    n = len(list(grafo.nodes()))
    
    def solucion(num, bas):
        
        iterador = My_Iterator(num_digits=num, base=bas)
        
        for combinacion in iterador.next():
            
            if len(combinacion) == len(set(combinacion)):
                if topological(combinacion):
                    solutions_list.append(combinacion)
        
        return solutions_list
                    
    def topological(n):
        for numero in n:
            s = [p for p in grafo.predecessors(numero)]
            if len(s) != 0:
                for p in s:
                    if n[p] > n[numero]:
                        return False
        
        for numero in n:
            s = [p for p in grafo.successors(numero)]
            if len(s) != 0:
                for p in s:
                    if n[p] < n[numero]:
                        return False
            
        return True
    
    solucion(n, n)
    return solutions_list


if "__main__" == __name__:
    
    input_list = (4, (0, 2), (1, 2), (2, 3), (2, 4))
    resultado = solve(input_list)
    
    print(resultado)

################# MEGA REPASOTE AP ################

import networkx as nx

def build_graph(edges_list, num_nodes, num_edges):
    graph = nx.Graph()
    
    for i in range(1, num_nodes + 1):
        graph.add_node(i)

    for i in range(0, num_edges): #Este bucle es así porque la lista recibida quita el primer elemento que es el número de noso y el número de ejes, entonces el número de ejes que antes era 5, desde el elemento 1 al 6 (1, num_edges + 1), pero como le quitamos el primer elemnto será ahora el primer eje el 0, entonces será de (0, num_edges).
        u, v = map(int, edges_list[i].split())
        graph.add_edge(u, v)
    
    return graph

def bfs_path_length(graph, first_node):
    
    distance = {} #{6:0, 4:1, 3:2, 5:2, 2:3, 1:4}
    nodos_repetidos = [] #6, 4, 5, 3, 2, 1
    nodo_actual = []
    nodo_actual.append(first_node)
    
    while len(nodo_actual) > 0:
        
        current_node = nodo_actual[0]#1
        nodo_actual.pop(0)
        
        if nodo_actual in nodos_repetidos:
            continue
        
        if current_node == first_node:
            
            distance[current_node] = 0
            
        nodos_repetidos.append(current_node)
        
        for vecino in graph.neighbors(current_node):
            
            if vecino not in nodos_repetidos:
                
                distance[vecino] = distance[current_node] + 1
                nodo_actual.append(vecino)
                nodos_repetidos.append(vecino)
    
    return distance


if "__main__" == __name__:
    
    input_list = ["6 7", "1 2", "1 3", "2 3", "2 4", "3 5", "5 4", "4 6"]
    
    num_nodes, num_edges = map(int, input_list[0].split())
    edges_list = input_list[1:] #QUITAMOS PRIMER ELEMENTO PARA QUE FUNCIONE COMO EN LA ULPGC
    
    first_node = 1
    grafo = build_graph(edges_list, num_nodes, num_edges)
    
    resultado = bfs_path_length(grafo, first_node)
    
    print(resultado)

#VERSIÓN UN POCO MEJORADA DEL EJERCICIO DE ARRIBA

def bfs_path_length(graph, first_node):
    
    distance = {}#{1: 0, 5: 1, 2: 1, 4: 2, 3: 2, 6: 3}
    nodos_vistos = set()#{1, 5, 2, 4, 3, 6}
    nodos_vistos.add(first_node)
    cola = [first_node]#[]
    
    while len(cola) != 0:
        
        nodo_actual = cola.pop(0)
        
        if nodo_actual == first_node:
            distance[nodo_actual] = 0
        
        for vecino in grafo.neighbors(nodo_actual):
            
            if vecino not in nodos_vistos:
                nodos_vistos.add(vecino)
                cola.append(vecino)
                distance[vecino] = distance[nodo_actual] + 1
    
    return distance

#Ejercicio componentes conectados, el examen de BFS, que me cayó a mi

import networkx as nx

def build_graph(edges_list, num_nodes, num_edges):
    graph = nx.Graph()
    
    for i in range(1, num_nodes + 1):
        graph.add_node(i)

    for i in range(0, num_edges): #Este bucle es así porque la lista recibida quita el primer elemento que es el número de noso y el número de ejes, entonces el número de ejes que antes era 5, desde el elemento 1 al 6 (1, num_edges + 1), pero como le quitamos el primer elemnto será ahora el primer eje el 0, entonces será de (0, num_edges).
        u, v = map(int, edges_list[i].split())
        graph.add_edge(u, v)
    
    return graph

def solve(graph):
    
    lista_final = [] #[1], [2, 6, 5], [3, 4]
    grupo_nodo = [] #
    grupillo = [] #
    nodos_vistos = set() #1, 2, 6, 5, 3, 4
    
    for node in grafo.nodes():
        
        if node in nodos_vistos:
            continue
        
        nodos_vistos.add(node)
        grupillo.append(node)
        
        while len(grupillo) > 0:
            
            current_node = grupillo.pop(0) #4
            if current_node not in grupo_nodo:
                grupo_nodo.append(current_node)
        
            for vecino in grafo.neighbors(current_node):
                
                if vecino not in grupo_nodo:
                    nodos_vistos.add(vecino)
                    grupo_nodo.append(vecino)
                    grupillo.append(vecino)
        
        lista_final.append(grupo_nodo)
        grupo_nodo = []
    
    for sublist in lista_final:
        sublist.sort()
    
    lista_final.sort()
    lista_final.sort(key=len)
    return lista_final


if "__main__" == __name__:
    
    input_list = ["6 3", "3 4", "5 6", "6 2"]
    
    num_nodes, num_edges = map(int, input_list[0].split())
    edges_list = input_list[1:] #QUITAMOS PRIMER ELEMENTO PARA QUE FUNCIONE COMO EN LA ULPGC
    
    grafo = build_graph(edges_list, num_nodes, num_edges)
    
    resultado = solve(grafo)
    
    print(resultado)

#Algortimo de DFS(forma iterativa)

def dfs_topological_sort(graph):

    nodos_vistos = set() #{0, 1, 4, 5, 2, 3, 6, 7} Este ejemplo es el que está en el Moddle
    nodo_actual = [] #[]
    #current_node =
    
    for node in graph.nodes():
        
        if (node in nodos_vistos):
            continue
        
        nodo_actual.append(node)
        
        while (len(nodo_actual) != 0):
            
            current_node = nodo_actual.pop()
            nodos_vistos.add(current_node)
            
            for vecino in grafo.neighbors(current_node):
                
                if (vecino not in nodos_vistos):
                    nodo_actual.append(vecino)
                    nodos_vistos.add(vecino)
                    
    return None #No returnea nada, por eso puse None, pero es para ver como es el algoritmo DFS de forma iterativa.

#Ejercicio de orden topológico de DFS recursivo del Moddle(con digrafo y sin pesos)

import networkx as nx

def build_graph(edges_list, num_nodes, num_edges):
    graph = nx.DiGraph()
    nodos_vistos = set()

    for i in range(0, num_edges): #Este bucle es así porque la lista recibida quita el primer elemento que es el número de noso y el número de ejes, entonces el número de ejes que antes era 5, desde el elemento 1 al 6 (1, num_edges + 1), pero como le quitamos el primer elemnto será ahora el primer eje el 0, entonces será de (0, num_edges).
        u, v, w = map(int, edges_list[i].split())
        if (u not in nodos_vistos):
            nodos_vistos.add(u)
        if (v not in nodos_vistos):
            nodos_vistos.add(v)
        graph.add_edge(u, v, weight=w)
    
    for node in nodos_vistos:
        graph.add_node(node)
    
    return graph

def dfs_topological_sort(graph):
    
    diccionario_actual = {}
    nodos_vistos = set() # {5, 11, 2, 9, 10, 7, 8}
    nodo_actual = [] #[]
    #current_node = 3
    N = graph.number_of_nodes()
    
    def dfs(u):
        
        nonlocal N
        
        for vecino in grafo.neighbors(u):
            
            if (vecino not in nodos_vistos):
                nodo_actual.append(vecino)
                nodos_vistos.add(vecino)
                dfs(vecino)

        diccionario_actual[u] = N
        N -= 1
        return
    
    for node in grafo.nodes():
        
        nodo_actual.append(node)
        
        while (len(nodo_actual) != 0):
            
            current_node = nodo_actual.pop()
            if (current_node not in nodos_vistos):
                nodos_vistos.add(current_node)
                dfs(current_node)
        
    d_swap = {v: k for k, v in diccionario_actual.items()}

    return dict(sorted(d_swap.items()))


if "__main__" == __name__:
    
    input_list = ["9 6", "1 2 2", "2 3 3", "4 5 5", "5 6 6", "7 8 8", "8 9 9"]
    
    num_nodes, num_edges = map(int, input_list[0].split())
    edges_list = input_list[1:] #QUITAMOS PRIMER ELEMENTO PARA QUE FUNCIONE COMO EN LA ULPGC
    
    grafo = build_graph(edges_list, num_nodes, num_edges)
    
    resultado = dfs_topological_sort(grafo)
    
    print(resultado)

#Mismo ejercicio que arriba pero en vez de hacerlo con recursividad lo hago de forma iterativa.

import networkx as nx

def build_graph(edges_list, num_nodes, num_edges):
    graph = nx.DiGraph()
    nodos_vistos = set()

    for i in range(0, num_edges): #Este bucle es así porque la lista recibida quita el primer elemento que es el número de noso y el número de ejes, entonces el número de ejes que antes era 5, desde el elemento 1 al 6 (1, num_edges + 1), pero como le quitamos el primer elemnto será ahora el primer eje el 0, entonces será de (0, num_edges).
        u, v = map(int, edges_list[i].split())
        if (u not in nodos_vistos):
            nodos_vistos.add(u)
        if (v not in nodos_vistos):
            nodos_vistos.add(v)
        graph.add_edge(u, v)
    
    for node in nodos_vistos:
        graph.add_node(node)
    
    return graph

def dfs_topological_sort(graph):
    
    diccionario_actual = {}
    nodos_vistos = set() # {1, 2, 4, 6, 3, 8, 5}
    lista_orden_iterativo = [] #[1, 2, 3, 4, 6, 3, 8, 5]
    lista_primeros_nodos = [] #[1, 2, 3]
    nodo_actual = [] #[]
    #current_node = 5
    
    def predecesores(u, graph):
    
        total_predecesores = list(graph.predecessors(u))#Vemos los predecesores que tiene
        no_estan = []
        
        for pred in total_predecesores:#Contamos los predecesores que están en los nodos_vistos y los que no están para saber si nos falta algún predecesor por ver
            if pred not in nodos_vistos:
                no_estan.append(pred)
        
        return no_estan#Returneamos la lista de predecesores
    
    def tieneCiclo(u, v, graph):
        for pred in graph.predecessors(v):
            if pred == u:  # se cerró el ciclo
                return True
            if tieneCiclo(u, pred, graph):
                return True
        return False
    
    for node in graph.nodes():
        
        if (len(list(graph.predecessors(node))) == 0):
            lista_primeros_nodos.append(node)
            lista_orden_iterativo.append(node)
    
    for nodo in lista_primeros_nodos:
        
        nodo_actual.append(nodo)
        
        while (len(nodo_actual) != 0):
            
            current_node = nodo_actual.pop()
            
            if tieneCiclo(current_node, current_node, graph):
                return "No se puede hacer el orden topológico si el grafo es acíclico."
            
            if (len(predecesores(current_node, graph)) == 0): #Si no tiene predecesores o todos los predecesores están en nodos vistos significa que lo podemos añadir
                
                if (current_node not in nodos_vistos):
                    nodos_vistos.add(current_node)
                    if (current_node not in lista_orden_iterativo):
                        lista_orden_iterativo.append(current_node)
                
                for vecino in grafo.neighbors(current_node):#Miramos a los vecinos y hacemos lo mismo que hicimos con el nodo que acabamos de ver
                    
                    nodo_actual.append(vecino)    
    
    if (len(lista_orden_iterativo) == 0):
        return "No se puede hacer el orden topológico si el grafo es acíclico."
    
    return lista_orden_iterativo


if "__main__" == __name__:
    
    input_list = ["8 9", "1 4", "2 4", "2 5", "3 5", "3 8", "4 6", "4 7", "4 8", "5 7"]
    
    num_nodes, num_edges = map(int, input_list[0].split())
    edges_list = input_list[1:] #QUITAMOS PRIMER ELEMENTO PARA QUE FUNCIONE COMO EN LA ULPGC
    
    grafo = build_graph(edges_list, num_nodes, num_edges)
    
    resultado = dfs_topological_sort(grafo)
    
    print(resultado)

#Problema del submarino DFS Recursivo(obviamente)

import networkx as nx

def solve(input_list):
    
    def build_graph(edges_list, num_edges):
        graph = nx.Graph()
        nodos_vistos = set()

        for i in range(0, num_edges): #Este bucle es así porque la lista recibida quita el primer elemento que es el número de noso y el número de ejes, entonces el número de ejes que antes era 5, desde el elemento 1 al 6 (1, num_edges + 1), pero como le quitamos el primer elemnto será ahora el primer eje el 0, entonces será de (0, num_edges).
            u, v =  edges_list[i].split("-")
            if (u not in nodos_vistos):
                nodos_vistos.add(u)
            if (v not in nodos_vistos):
                nodos_vistos.add(v)
            graph.add_edge(u, v)
        
        for node in nodos_vistos:
            graph.add_node(node)
        
        return graph
    
    grafo = build_graph(input_list, len(input_list))
    nodos_visitados = set() #{c, b, }
    camino_actual = ["start"] #["start", A, c, A]
    todos_los_caminos = []
    
    def backtricks(grafo, nodo_actual):
        
        if nodo_actual == "end":
            todos_los_caminos.append(list(camino_actual))
            return
        
        for vecino in grafo.neighbors(nodo_actual):#start
            
            if vecino in nodos_visitados and vecino.islower():
                continue
            
            if vecino == "start":
                continue
            
            nodos_visitados.add(vecino)
            camino_actual.append(vecino)
            backtricks(grafo, vecino)
            camino_actual.pop()
            nodos_visitados.discard(vecino)
        
        return
            
    backtricks(grafo, "start")
    return (len(todos_los_caminos), todos_los_caminos)


if "__main__" == __name__:
    
    input_list = ["fs-end", "he-DX", "fs-he", "start-DX", "pj-DX", "end-zg", "zg-sl", "zg-pj", "pj-he", "RW-he", "fs-DX", "pj-RW", "zg-RW", "start-pj", "he-WI", "zg-he", "pj-fs", "start-RW"]
    
    num_edges = len(input_list)
    
    numero_soluciones, lista_de_soluciones = solve(input_list)
    
    lista_de_soluciones.sort()
    lista_de_soluciones.sort(key=len)
    
    for lista in lista_de_soluciones:
        print(lista)
    
    print(numero_soluciones)

#Problema de las N-Reinas con backtracking

def solve(num_queens):
    
    solucion_actual = []#[1, 3]
    filas_vistas = set()#{1, 3}
    total_soluciones = []
    
    def backtrixs(num_queens, n):#n=2
        
        if len(solucion_actual) == num_queens:
            total_soluciones.append(list(solucion_actual))
            return
        
        for i in range(0, num_queens):#i=2
            esta_diagonal = 0#Reiniciamos la variable a 0 ya que en el bucle anterior lo dejamos a 1
            
            for reina in solucion_actual:
                valor_columnas = abs(solucion_actual.index(reina) - n)#Restamos el número de columnas de una reina con otra para ver su posición diagonal
                if valor_columnas == abs(i - reina):#Luego hacemos lo mimso con las filas y si nos da el mismo valor están en la misma diagonal
                    esta_diagonal = 1#Para detectar que si están en la misma diagonal
                    break
            
            if esta_diagonal == 1:#Si están se descarta esta iteración
                continue
            
            if i in filas_vistas:
                continue
            
            solucion_actual.append(i)
            filas_vistas.add(i)
            backtrixs(num_queens, n + 1)
            solucion_actual.pop()
            filas_vistas.remove(i)
        
        return
    
    backtrixs(num_queens, 0)
    return total_soluciones


if "__main__" == __name__:
    
    num_queens = 4
    
    numero_soluciones = solve(num_queens)
    
    for solucion in numero_soluciones:
        print(solucion)

#Problema del cargador hecho con BACKTRACKING

import networkx as nx

def solve(input_list, voltage):
    
    def build_graph(input_list):
        
        graph = nx.Graph()
        nodos_vistos = set()
        
        for tupla in input_list:
            
            u, v = map(int, tupla.split())
            
            if u not in nodos_vistos:
                nodos_vistos.add(u)
            if v not in nodos_vistos:
                nodos_vistos.add(v)
            
            graph.add_edge(u,v)
        
        for node in nodos_vistos:
            graph.add_node(node)
    
        return graph
    
    grafo = build_graph(input_list)
    
    solucion_actual = []#[0]
    mejor_solucion = []#[[0, 3, 4, 5, 8, 9, 13], [0, 3, 4, 6, 7, 9, 13], [0, 5, 7, 9, 13], [0, 2, 10, 13]]
    
    def poda(lista):
        if len(lista) > len(mejor_solucion[0]):
            return True
        
        return False
    
    def backtrinx(graph, u):
        
        if u == voltage:
            if len(mejor_solucion) == 0:
                mejor_solucion.append(list(solucion_actual))
            elif len(mejor_solucion) > 0:
                if len(solucion_actual) < len(mejor_solucion[0]):
                    mejor_solucion.clear()
                    mejor_solucion.append(list(solucion_actual))
                elif len(solucion_actual) == len(mejor_solucion[0]):
                    mejor_solucion.append(list(solucion_actual))

            return
        
        if len(mejor_solucion) != 0 and poda(solucion_actual):
            return
        
        for vecino in graph.neighbors(u):
            
            if vecino < u:
                continue
            
            solucion_actual.append((u, vecino))
            backtrinx(graph, vecino)
            solucion_actual.pop()
        
        return
    
    backtrinx(grafo, 0)
    return mejor_solucion


if "__main__" == __name__:
    
    edges_list = ["15 13", "0 3", "2 10", "3 4", "4 5", "5 8", "8 9", "9 13", "3 4", "4 6", "6 7", "0 5", "5 7", "7 9", "0 2", "10 13"]
    
    cargadores, voltaje = map(int, edges_list[0].split())
    intput_list = edges_list[1:]
    
    numero_soluciones = solve(intput_list, voltaje)
    
    for lista in numero_soluciones:
        print(lista)
    
    print(len(numero_soluciones), "solutions")

#Ejercicio del siguiente número

def next_number(digits, base):#([0,1,0,1,1], 2)
    next_digits = digits.copy()#[0,1,1,0,0]
    limite = base - 1#1
    cambiar_siguiente = 1#0
    for i in range(len(next_digits)-1, -1, -1):
        
        if cambiar_siguiente == 1:
            if next_digits[i] < limite:
                next_digits[i] += 1
                cambiar_siguiente = 0
            else:
                next_digits[i] = 0
                cambiar_siguiente = 1
    
    return next_digits

print(next_number([0,1,0,1,1], 2))

#Ejercicio de funciones generadoras

def next_number(digits, base):#([0,1,0,1,1], 2)
    next_digits = digits.copy()#[0,1,1,0,0]
    limite = base - 1#1
    cambiar_siguiente = 1#0
    for i in range(len(next_digits)-1, -1, -1):
        
        if cambiar_siguiente == 1:
            if next_digits[i] < limite:
                next_digits[i] += 1
                cambiar_siguiente = 0
            else:
                next_digits[i] = 0
                cambiar_siguiente = 1
    
    return next_digits

class My_Iterator:

    def __init__(self, num_digits, base):
        self.num_digits = num_digits
        self.base = base

    def next(self):
        inicial = [0] * self.num_digits
        repeticones = self.base ** self.num_digits
        for i in range(repeticones):
                yield inicial
                inicial = next_number(inicial, self.base)

        return

it = My_Iterator(3,4)
for n in it.next():
    print(n)

#Ejercicio de N-Queens con Fuerza bruta

def next_number(digits, base):#([0,1,0,1,1], 2)
    next_digits = digits.copy()#[0,1,1,0,0]
    limite = base - 1#1
    cambiar_siguiente = 1#0
    for i in range(len(next_digits)-1, -1, -1):
        
        if cambiar_siguiente == 1:
            if next_digits[i] < limite:
                next_digits[i] += 1
                cambiar_siguiente = 0
            else:
                next_digits[i] = 0
                cambiar_siguiente = 1
    
    return next_digits

class My_Iterator:

    def __init__(self, num_digits, base):
        self.num_digits = num_digits
        self.base = base

    def next(self):
        inicial = [0] * self.num_digits
        repeticones = self.base ** self.num_digits
        for i in range(repeticones):
                yield inicial
                inicial = next_number(inicial, self.base)
                
        return

def solve(num_queens):
    
    def comprobar_diagonal(n):#[1,3,2,0]
        
        for i in range(0, len(n)):#0
            for j in range(0, len(n)):#2
                if i == j:
                    continue
                
                valor1 = abs(n.index(n[i]) - n.index(n[j]))#1
                valor2 = abs(n[i] - n[j])#1
                
                if valor1 == valor2:
                    return True
        
        return False
    
    total_soluciones = []
    combinaciones = My_Iterator(num_queens, num_queens)
    
    for n in combinaciones.next():
        
        if len(n) == len(set(n)):#Para comprobar que todos los valores son distintos
            
            if comprobar_diagonal(n):
                continue
            
            total_soluciones.append(n)

    return total_soluciones


if "__main__" == __name__:
    
    num_queens = 4
    
    resultado = solve(num_queens)
    
    for solution in resultado:
        print(solution)

#Ejercicio de iterador con valores concretos

def next_number(digits, lista_envio):#([6,7,9], 2)
    next_digits = digits.copy()#[6, 7, 2]
    cambiar_siguiente = 1
    for i in range(len(next_digits)-1, -1, -1):
        
        #Creamos el límite como el último elemento de cada sublista, para saber cuando reiniciar
        limite = lista_envio[i][-1]#2
        
        if cambiar_siguiente == 1:
            if lista_envio[i].index(next_digits[i]) < lista_envio[i].index(limite):#Si el digito actual es mas pequeño que el limite, entonces le sumamos uno a la posicion en la sublista
                next_digits[i] = lista_envio[i][lista_envio[i].index(next_digits[i]) + 1]
                cambiar_siguiente = 0
            else:#Y si el elemento ya esta en el limite de la sublista se reinicia a cero
                next_digits[i] = lista_envio[i][0]
                cambiar_siguiente = 1
    
    return next_digits

class My_Iterator:

    def __init__(self, num_digits, lista_envio):
        self.num_digits = num_digits
        self.lista_envio = lista_envio

    def next(self):
        inicial = []
        repeticiones = 0
            
        #Creamos el elemento inicial con los primeros elementos de cada sublista de la lista de entrada
        inicial = [lista_envio[i][0] for i in range(0, len(lista_envio))]
        
        #Aqui lo que hacemos es por cada numero del primer elemento de la lista contamos ese numero, que es el +1, y luego contamos los demas numeros de los otros elementos de la lista de entrada para saber asi el total de combinaciones que hay
        for element in lista_envio[0]:
            repeticiones += 1
            for i in range(1, len(lista_envio)):
                repeticiones += len(lista_envio[i])
        
        for i in range(repeticiones):
                yield inicial
                inicial = next_number(inicial, self.lista_envio)
                
        return

digit_values = ["3", "6 2", "7 3 1", "9 2"]
    
lista_envio = []
    
for element in digit_values[1:]:
    lista = [e for e in map(int, element.split())]
    lista_envio.append(lista)
    
obj = My_Iterator(len(lista_envio), lista_envio)#Aqui el valor de base(en el original) ahora toma el valor de los dígitos en las diferentes combianciones
    
for c in obj.next():
    print(c)

#Ejercicio de órdenes topológicos con Fuerza bruta

import networkx as nx

def next_number(digits, base):#([0,1,0,1,1], 2)
        next_digits = digits.copy()#[0,1,1,0,0]
        limite = base - 1#1
        cambiar_siguiente = 1#0
        for i in range(len(next_digits)-1, -1, -1):
            
            if cambiar_siguiente == 1:
                if next_digits[i] < limite:
                    next_digits[i] += 1
                    cambiar_siguiente = 0
                else:
                    next_digits[i] = 0
                    cambiar_siguiente = 1
        
        return next_digits

class My_Iterator:

        def __init__(self, num_digits, base):
            self.num_digits = num_digits
            self.base = base

        def next(self):
            inicial = [0] * self.num_digits
            repeticones = self.base ** self.num_digits
            for i in range(repeticones):
                    yield inicial
                    inicial = next_number(inicial, self.base)
                    
            return

def solve(input_list):
    
    solutions_list = []
    
    def build_graph(input_list):
        
        graph = nx.DiGraph()
        nodos_vistos = set()
        
        for s in input_list:
            u, v = map(int, s.split())
            
            if u not in nodos_vistos:
                nodos_vistos.add(u)
            elif v not in nodos_vistos:
                nodos_vistos.add(v)
            
            graph.add_edge(u, v)
        
        for node in nodos_vistos:
            graph.add_node(node)
        
        return graph
    
    grafo = build_graph(input_list)
    
    def validacion(graphix, c):#[0, 1, 2, 3, 4]
        
        for n in c:#2
                
            for p in graphix.predecessors(n):
                
                if c.index(p) > c.index(n):
                    
                    return True
                    
            for s in graphix.successors(n):
                
                if c.index(s) < c.index(n):
                    
                    return True
        
        return False
    
    def topologic(g):
        
        obj = My_Iterator(len(g.nodes()), len(g.edges()) + 1)
        
        for combinacion in obj.next():#[0, 1, 2, 3, 4]
            
            if len(combinacion) == len(set(combinacion)):
                
                if validacion(g, combinacion):
                    continue
                else:
                    solutions_list.append(combinacion)

    a = topologic(grafo)

    return solutions_list


if "__main__" == __name__:
    
    input_list = ["4", "0 2", "1 2", "2 3", "2 4"]
    
    resultado = solve(input_list[1:])
    
    for sublist in resultado:
        print(sublist)
    
    print(len(resultado), "solutions")

#Ejercicio de la mochila con Fuerza bruta

def next_number(digits, base):#([0,1,0,1,1], 2)
        next_digits = digits.copy()#[0,1,1,0,0]
        limite = base - 1#1
        cambiar_siguiente = 1#0
        for i in range(len(next_digits)-1, -1, -1):
            
            if cambiar_siguiente == 1:
                if next_digits[i] < limite:
                    next_digits[i] += 1
                    cambiar_siguiente = 0
                else:
                    next_digits[i] = 0
                    cambiar_siguiente = 1
        
        return next_digits

class My_Iterator:

        def __init__(self, num_digits, base):
            self.num_digits = num_digits
            self.base = base

        def next(self):
            inicial = [0] * self.num_digits
            repeticones = self.base ** self.num_digits
            for i in range(repeticones):
                    yield inicial
                    inicial = next_number(inicial, self.base)
                    
            return

def solve(capacity, input_list):
    
    solution = []
    valores = []
    pesos = []
    
    for i in range(0, len(input_list)):
        
        u, v = input_list[i].split()
        valores.append(int(u))
        pesos.append(int(v))        

    def mochilix(valores, pesos):
        
        best_value = 0
        
        obj = My_Iterator(len(valores), 2)
        
        for combinacion in obj.next():
        
            peso_total = sum([pesos[indice] for indice, valor in enumerate(combinacion) if valor == 1])
            
            if peso_total <= capacity:
                
                valor_total = sum([valores[indice] for indice, valor in enumerate(combinacion) if valor == 1])
                
                if valor_total > best_value:
                    best_value = valor_total
                    solution = [indice + 1 for indice, valor in enumerate(combinacion) if valor == 1]
        
        return best_value, solution
    
    r = mochilix(valores, pesos)
    return r


if "__main__" == __name__:
    
    input_list = ["4 11", "8 4", "10 5", "15 8", "4 3"]
    
    best_value, solucion = solve(11, input_list[1:])
    
    solucion.sort()
    print(f"{solucion} {best_value}")

#Problema de devolución del cambio con DFS

def solve(coins, change):
    
    solutions_list = []
    solucion_actual = []
    
    def dfs_recursivo(current_money, contador):
        
        if current_money == change:
            solutions_list.append(list(solucion_actual))
            return
        
        for i in range(contador, len(coins)):
            
            if (current_money + coins[i]) > change:
                continue
            
            solucion_actual.append(i + 1)
            dfs_recursivo(current_money + coins[i], i + 1)
            solucion_actual.pop()
        
        return
    
    dfs_recursivo(0, 0)

    if len(solutions_list) > 0:
        return solutions_list
    else:
        return None


if "__main__" == __name__:
    
    coins = [5, 2, 1, 10, 10, 2]
    
    change = 12
    
    resultado = solve(coins, change)
    
    if resultado:
        print(sorted(resultado, reverse=True))
   
        if len(resultado) == 1:
            print('1 solución')
        else:
            print(len(resultado), 'soluciones')

    else:
        print('No hay solucion')

#Problema de los sensores con Greedy, MST y DFS

import networkx as nx

def build_graph(num_nodes, num_edges, input_list):
    
    graph = nx.Graph()
    
    for node in input_list[0].split():
        graph.add_node(node)
    
    for i in range(1, len(input_list)):
        nodo1, nodo2, peso = input_list[i].split()
        peso_numero = int(peso)
        graph.add_edge(nodo1, nodo2, weight=peso_numero)
    
    return graph

def kruskal_mst_dfs(G):
    
    tuplas_totales = []
    grafo_protector_de_ciclos = nx.Graph()
    mst_cost = 0
    energy_loss_mW = 0
    complete_cost = 0
    aristas_cogidas = []
    
    def esConexo(g, nodo):
        visited = set()
        
        def dfs(n):
            visited.add(n)
            for vecino in g.neighbors(n):
                if vecino not in visited:
                    dfs(vecino)
        
        dfs(nodo)
        
        return len(visited) == len(g.nodes())

    def tieneCiclo(nodo_actual, padre, graphix, visitados=None):
        if visitados is None:
            visitados = set()
        visitados.add(nodo_actual)

        for vecino in graphix.neighbors(nodo_actual):
            if vecino == padre:
                continue

            if vecino in visitados:
                return True

            if tieneCiclo(vecino, nodo_actual, graphix, visitados):
                return True

        return False
    
    for u, v, data in G.edges(data=True):#MCU S2 10
        
        peso = data.get('weight')
        
        for i in range(0, len(tuplas_totales)):
            
            if (peso, u, v) in tuplas_totales:
                continue
            
            if peso < tuplas_totales[i][0]:
                tuplas_totales.insert(i, (peso, u, v))
            elif u < tuplas_totales[i][1]:
                tuplas_totales.insert(i, (peso, u, v))
            elif v < tuplas_totales[i][2]:
                tuplas_totales.insert(i, (peso, u, v))
        
        if (peso, u, v) not in tuplas_totales:
            tuplas_totales.append((peso, u, v))
    
    if not esConexo(G, tuplas_totales[0][1]):
        return None
    
    for tupla in tuplas_totales:
        u, v = tupla[1:]#MS1, S2
        if u not in grafo_protector_de_ciclos.nodes():
            grafo_protector_de_ciclos.add_node(u)
        if v not in grafo_protector_de_ciclos.nodes():
            grafo_protector_de_ciclos.add_node(v)
        
        grafo_protector_de_ciclos.add_edge(u, v)
        if not tieneCiclo(u, u, grafo_protector_de_ciclos, set()):
            
            tupla_mod = (u, v, tupla[0])
            aristas_cogidas.append(tupla_mod)#[[MCU, S1, 10], [MCU, S2, 15]]
            mst_cost += tupla[0]#25
            
        else:
            
            grafo_protector_de_ciclos.remove_edge(u, v)
            
        complete_cost += tupla[0]
    
    return aristas_cogidas, mst_cost, complete_cost


if "__main__" == __name__:
    
    enter_list = ["5 7", "MCU N1 N2 N3", "MCU N1 1", "N1 N2 1", "N2 N3 1", "MCU N2 1", "MCU N3 2", "N1 N3 2", "N2 MCU 1"]
    
    numero_nodos, numero_aristas = map(int, enter_list[0].split())
    
    grafo = build_graph(numero_nodos, numero_aristas, enter_list[1:])
    
    mst, mst_cost, complete_cost = kruskal_mst_dfs(grafo)
    
    mst_norm = []
    for (u, v, w) in mst:
        a, b = (u, v) if u <= v else (v, u)
        mst_norm.append((a, b, w))
    mst_norm.sort(key=lambda e: (e[2], e[0], e[1]))
    
    energy_loss_mw = mst_cost # 1mW/cm
    mst_lines = [f"{u} {v} {w}" for (u, v, w) in mst_norm]

    out = []
    out.append("MST:")
    out.extend(mst_lines)
    out.append(f"MST_cost={mst_cost}")
    out.append(f"Complete_cost={complete_cost}")
    out.append(f"Energy_loss_mW={energy_loss_mw}")
    print("\n".join(out))

#Problema de la mochila hecho con Backtracking y greedy

def solve(budget, items):
    
    valores = {}
    cantidades = {}
    productos_ordenados = []
    for tupla in items:
        productos_ordenados.append(tupla[0])
        valores[tupla[0]] = tupla[1] * tupla[2]
        cantidades[tupla[0]] = tupla[2]
    
    productos_ordenados.sort()
    
    solucion_optima = []
    solucion_actual = []
    best_value = 0
    best_quantity = 0
    
    def supera_presupuesto(n):
        
        if n > budget:
            return True
        
        return False
    
    def backtrix(cantidad_total, coste_total, productos_ordenados, valores, contador):#9, [kiwi, manzanas, peras, uvas], 1
        
        nonlocal best_value, best_quantity
        
        if contador == len(productos_ordenados): 
            if len(solucion_actual) > 0:
                if len(solucion_optima) == 0: 
                    solucion_optima.append((list(solucion_actual), cantidad_total, coste_total)) 
                    best_value = coste_total
                    best_quantity = cantidad_total
                elif cantidad_total > best_quantity: 
                    solucion_optima[0] = ((list(solucion_actual), cantidad_total, coste_total)) 
                    best_value = coste_total
                    best_quantity = cantidad_total
                elif cantidad_total == best_quantity: 
                    solucion_optima.append((list(solucion_actual), cantidad_total, coste_total))
            
            return
        
        for i in range(contador, len(productos_ordenados)):
            
            if supera_presupuesto(coste_total + valores[productos_ordenados[i]]):
                backtrix(cantidad_total, coste_total, productos_ordenados, valores, i + 1)
                return

            solucion_actual.append(productos_ordenados[i])
            backtrix(cantidad_total + cantidades[productos_ordenados[i]], coste_total + valores[productos_ordenados[i]], productos_ordenados, valores, i + 1)
            solucion_actual.pop()
        
        return
    
    backtrix(0, 0, productos_ordenados, valores, 0)
    
    if len(solucion_optima) == 0:
        return 0, []
    
    if len(solucion_optima) > 1:
        
        resultado = max(solucion_optima, key=lambda x: x[1])
        
        return resultado[1], resultado[0]
    
    return solucion_optima[0][1], solucion_optima[0][0]


if "__main__" == __name__:#cantidad, coste
    enter_list = [("pan", 1, 2, 2), ("leche", 1, 3, 3), ("huevos", 1, 12, 12)]
    budget = 10

    best_qty, solution = solve(budget, enter_list)
    
    solution.sort()
    print(f"{best_qty} {solution}", end="")

#Coloreado de grafos hecho con greedy

import networkx as nx

def build_graph(input_list):
    graph = nx.Graph()
    for edge in input_list:
        u, v = map(int, edge.split())
        graph.add_edge(u, v)
    return graph

def rlf_graph_coloring(graphix):
    colors = {}
    nodes = set(graphix.nodes())
    color = 0

    while nodes:
        grados = {node: len(list(graphix.neighbors(node))) for node in nodes}
        if not grados:
            break
        numero_maximo_aristas = max(grados.values())

        nodos_con_mismo_grado = [n for n in nodes if len(list(graphix.neighbors(n))) == numero_maximo_aristas]

        coloreados_actual = set()

        if nodos_con_mismo_grado:
            nodo_inicial = nodos_con_mismo_grado[0]
            colors[nodo_inicial] = color
            coloreados_actual.add(nodo_inicial)

        for nodo in nodos_con_mismo_grado[1:]:
            adyacente = False
            for c in coloreados_actual:
                if nodo in graphix.neighbors(c):
                    adyacente = True
                    break
            if not adyacente:
                colors[nodo] = color
                coloreados_actual.add(nodo)

        nodes -= coloreados_actual

        color += 1

    return colors


if "__main__" == __name__:
    enter_list = ["7 12", "1 2", "2 3", "3 4", "4 5", "5 6", "6 1", "1 7", "2 7", "3 7", "4 7", "5 7", "6 7"]

    grafo = build_graph(enter_list[1:])

    resultado = rlf_graph_coloring(grafo)

    sorted_dict = {k: resultado[k] for k in sorted(resultado)}
    print(list(sorted_dict.values()))

#Mochila cogiendo el máximo valor posible

def mochila_con_poda(valores, pesos, capacidad):
    
    mejor_solucion = []
    mejor_valor = 0
    combinacion_actual = []
    
    def backtracking(valor_actual, peso_actual, contador):
        
        nonlocal mejor_valor
        
        if contador == len(pesos):
            if len(mejor_solucion) == 0:
                mejor_solucion.append(list(combinacion_actual))
                mejor_valor = valor_actual
            elif len(mejor_solucion) != 0 and valor_actual > mejor_valor:
                mejor_solucion[0] = list(combinacion_actual)
                mejor_valor = valor_actual
            
            return
        
        for i in range(contador, len(pesos)):
            
            if (peso_actual + pesos[i]) > capacidad:
                backtracking(valor_actual, peso_actual, i + 1)
                continue
            
            combinacion_actual.append(i + 1)
            backtracking(valor_actual + valores[i], peso_actual + pesos[i], i + 1)
            combinacion_actual.pop()
            
        return
    
    backtracking(0, 0, 0)
    return mejor_valor, mejor_solucion[0]


if "__main__" == __name__:
    valores = [8, 10, 15, 4]
    pesos = [4, 5, 8, 3]
    capacidad = 11
      
    mejor_valor, mejor_solucion = mochila_con_poda(valores, pesos, capacidad)
    
    print(f"El valor maximo obtenido es {mejor_valor} cogiendo los objetos {mejor_solucion}")

#Mochila cogiendo el mínimo valor posible(con poda)

def mochila_con_poda(valores, pesos, capacidad):
    
    mejor_solucion = []
    mejor_valor = 999
    combinacion_actual = []
    
    def poda(valor):
        
        if valor <= mejor_valor:
            return False
        
        return True
    
    def backtracking(valor_actual, peso_actual, contador):
        
        nonlocal mejor_valor
        
        if valor_actual < mejor_valor and valor_actual != 0:
            if len(mejor_solucion) == 0:
                mejor_solucion.append(list(combinacion_actual))
                mejor_valor = valor_actual
            elif len(mejor_solucion) != 0:
                mejor_solucion[0] = list(combinacion_actual)
                mejor_valor = valor_actual
        
        for i in range(contador, len(pesos)):
            
            if poda(valor_actual):
                backtracking(valor_actual, peso_actual, i + 1)
                return
            
            combinacion_actual.append(i + 1)
            backtracking(valor_actual + valores[i], peso_actual + pesos[i], i + 1)
            combinacion_actual.pop()
            
        return
    
    backtracking(0, 0, 0)
    return mejor_valor, mejor_solucion[0]


if "__main__" == __name__:
    valores = [8, 1, 2, 10]
    pesos = [4, 5, 8, 3]
    capacidad = 11
      
    mejor_valor, mejor_solucion = mochila_con_poda(valores, pesos, capacidad)
    
    print(f"El valor mínimo obtenido es {mejor_valor} cogiendo los objetos {mejor_solucion}")

#Problema FICTICIO de amgiso sociales con BFS

import networkx as nx

def build_graph(edges_list, num_nodes, num_edges):
    graph = nx.Graph()
    nodos_vistos = set()

    for i in range(0, num_edges): #Este bucle es así porque la lista recibida quita el primer elemento que es el número de noso y el número de ejes, entonces el número de ejes que antes era 5, desde el elemento 1 al 6 (1, num_edges + 1), pero como le quitamos el primer elemnto será ahora el primer eje el 0, entonces será de (0, num_edges).
        u, v = edges_list[i].split()
        graph.add_edge(u, v)
    
    return graph

def bfs_path_length(graph, first_node, last_node):
    
    numero_saltos = 0#2
    distance = {}#{Ana: 0, Fernando: 1, Carla: 1, Alejandro: 2, Eva: 3, Diego: 3, Beatriz: 3, Mario: 4}
    nodos_vistos = set()#{Ana, Fernando, Carla, Alejandro, Eva, Diego, Beatriz, Mario}
    cola = [first_node]#[Mario]
    
    while len(cola) != 0:
        
        nodo_actual = cola.pop(0)#Eva
        
        if nodo_actual == last_node:
            return distance[last_node]
        
        if nodo_actual == first_node:
            distance[nodo_actual] = 0
        
        if nodo_actual not in nodos_vistos:
            nodos_vistos.add(nodo_actual)
        
        for vecino in graph.neighbors(nodo_actual):
            
            if vecino not in nodos_vistos:
                cola.append(vecino)
                nodos_vistos.add(vecino)
                distance[vecino] = distance[nodo_actual] + 1
    
    return None


if "__main__" == __name__:
    
    input_list = ["8 8", "Ana Fernando", "Ana Carla", "Fernando Alejandro", "Carla Alejandro", "Alejandro Eva", "Alejandro Diego", "Alejandro Beatriz", "Eva Mario"]
    
    num_nodes, num_edges = map(int, input_list[0].split())
    edges_list = input_list[1:] #QUITAMOS PRIMER ELEMENTO PARA QUE FUNCIONE COMO EN LA ULPGC

    grafo = build_graph(edges_list, num_nodes, num_edges)
    
    resultado = bfs_path_length(grafo, "Ana", "Mario")
    
    if resultado == None:
        print("No es posible encontrar una conexión.")
    
    print(f"La conexión es de {resultado} saltos.")

#Ejercicio como el de arriba pero con el camino más corto

import networkx as nx

def build_graph(edges_list, num_nodes, num_edges):
    graph = nx.Graph()
    nodos_vistos = set()

    for i in range(0, num_edges): #Este bucle es así porque la lista recibida quita el primer elemento que es el número de noso y el número de ejes, entonces el número de ejes que antes era 5, desde el elemento 1 al 6 (1, num_edges + 1), pero como le quitamos el primer elemnto será ahora el primer eje el 0, entonces será de (0, num_edges).
        u, v = edges_list[i].split()
        graph.add_edge(u, v)
    
    return graph

def bfs_path_length(graph, first_node, last_node):
    
    distance = {}#{Ana: 0, Fernando: 1, Carla: 1, Alejandro: 2, Eva: 3, Diego: 3, Beatriz: 3, Mario: 4}
    nodos_vistos = set()#{Ana, Fernando, Carla, Alejandro, Eva, Diego, Beatriz, Mario}
    caminos_actuales_copia = []
    caminos_actuales = [[first_node]]#[[]]
    cola = [first_node]#[Mario]
    
    if first_node == last_node:
        return 0, None
    
    while len(cola) != 0:
        
        nodo_actual = cola.pop(0)#Eva
        
        if nodo_actual == last_node:
            return distance[last_node], caminos_actuales[-1]
        
        if nodo_actual == first_node:
            distance[nodo_actual] = 0
        
        if nodo_actual not in nodos_vistos:
            nodos_vistos.add(nodo_actual)
            
        for camino in caminos_actuales:
            
            if camino[-1] == nodo_actual:
                
                for vecino in graph.neighbors(nodo_actual):
            
                    if vecino not in nodos_vistos:
                        caminos_actuales_copia = camino.copy()
                        caminos_actuales_copia.append(vecino)
                        caminos_actuales.append(caminos_actuales_copia)
                        cola.append(vecino)
                        nodos_vistos.add(vecino)
                        distance[vecino] = distance[nodo_actual] + 1
    
    return None, None


if "__main__" == __name__:
    
    input_list = ["8 8", "Ana Fernando", "Ana Carla", "Fernando Alejandro", "Carla Alejandro", "Alejandro Eva", "Alejandro Diego", "Alejandro Beatriz", "Eva Mario"]
    
    num_nodes, num_edges = map(int, input_list[0].split())
    edges_list = input_list[1:] #QUITAMOS PRIMER ELEMENTO PARA QUE FUNCIONE COMO EN LA ULPGC

    grafo = build_graph(edges_list, num_nodes, num_edges)
    
    resultado = bfs_path_length(grafo, "Ana", "Mario")
    
    print(resultado)

#Ejercicio Branch and Bound de ver todo el recorrido del árbol sin poda

from collections import namedtuple

Item = namedtuple("Item", ['index', 'value', 'weight'])

class Node:
    def __init__(self, index, taken, value, room):
        self.index = index
        self.taken = taken
        self.value = value
        self.room = room
        return

    def estimate(self, items, weights):
        bound = self.value #Valor actual del nodo, 0
        peso = self.room #Espacio actual del nodo, 10
        for i in range(self.index, len(items)):#1, 2
            peso -= weights[i]
            bound += items[i]
        return bound

def solve_branch_and_bound_DFS(capacity, items, record_visiting_order = False):
    """"
    :param capacity: capacidad de la mochila
    :param items: items de la mochila
    :param record_visiting_order: activa/desactiva el registro de nodos visitados
    :return: Por ahora sólo devuelve la lista de nodos visitados
    """
    values = []
    weights = []
    for i in range(0, len(items)):
        u, v, w = items[i]
        values.append(v)
        weights.append(w)
    
    #Si nos pidieran el mejor valor esto si se pondría
    
    #best_value = 0
    #best_taken = []
    
    ##################################################

    # Completa este código para realizar el recorrido DFS; tienes
    # indicados los sitios que debes completar con tres puntos
    # suspensivos ("...")

    # Utilizamos la lista 'alive' como nuestra pila de nodos vivos
    # (pendientes de visitar) para programar nuestro recorrido DFS.
    
    alive = []
    
    # Utilizamos la lista Visiting_Order como el registro de nodos
    # visitados (el contenido final de esta lista lo utiliza el VPL
    # para comprobar que nuestro recorrido DFS es correcto).

    visiting_order = []

    # 1) Creamos el nodo raiz (en este VPL todavía no utilizamos los
    #    parámetros taken, value, room, con lo que se inicializan con
    #    lista vacía y 0). El único valor necesario en el nodo es el
    #    indice al primer elemento de la lista (index = 0).
    # ...
    nodo_raiz = Node(0, [], 0, capacity)
    
    #if record_visiting_order is False:
    #    record_visiting_order = set()
    #    record_visiting_order.add(nodo_raiz)

    # Lo añadimos a la lista de nodos vivos (alive)
    # ...
    alive.append(nodo_raiz)

    # Mientras haya nodos en la lista de nodos vivos
    # ...
    while len(alive) != 0:#[0, 1, 2,]
                          #[1I, 2I, ]
        
        # Avanzamos al siguiente nodo de nuestro recorrido DFS (hacemos un pop
        # de la lista) y lo registramos en nuestro recorrido DFS.

        current_node = alive.pop()##Nodo raiz
        
        visiting_order.append(current_node.index)
        
        #En este caso no te esta pidiendo el mojer valor o la mejor combinacion, sino que recorras el árbol completo entonces quitamos la poda.
        
        #if current_node.room <= 0:
        #    continue
        
        #El método estimate lo que hace es devolver el valor máximo posible de la rama que estamos mirando, entonces si ese valor es más pequeño que el mejor valor actual no vale la pena seguir mirando la rama y se poda
        
        #if current_node.estimate < best_value:.
        #    continue
        
        #No buscamos el mejor valor, ya que no hay poda
        
        #if current_node.value > best_value:
        #    best_value = current_node.value
        #    best_taken = current_node.taken
        
        ###############################################

        # Si no hemos llegado al final del árbol
        #    1) Ramificamos (branch) por la derecha (append)
        #    2) Ramificamos (branch) por la izquierda (append)
        # ...
        if current_node.index < len(items):
            taken_left = current_node.taken.copy()
            taken_left.append(current_node.index)
            nodo_izquierdo = Node(current_node.index + 1, taken_left, current_node.value + values[current_node.index], current_node.room - weights[current_node.index])#[1, [1, ], ]
            nodo_derecho = Node(current_node.index + 1, current_node.taken.copy(), current_node.value, current_node.room)
            alive.append(nodo_izquierdo)
            alive.append(nodo_derecho)

    #Esta sería la solución viable si te piden el mejor valor, pero solote piden el visiting_order completo del árbol.
    
    #return best_value, best_taken, visiting_order
    
    #Como los dos primeros parámetros dan igual pues ponemos lo que sea y devolvemos el visiting_order sin poda
    
    return 0, [], visiting_order


if "__main__" == __name__:
    
    resultado = solve_branch_and_bound_DFS(10, [(0, 45, 5), (1, 48, 8), (2, 35, 3)], set())
    
    print(resultado)

#Array ordenado con merge_sort

def sort_playlist_by_flow(tracks):#[title, bpm, (int energy)opcional]
    
    def ordenar_array(elemento1, elemento2):#[1], [6]
        
        array_ordenado = []#[1]
        i, j = 0, 0#1, 0
        
        while i < len(elemento1) and j < len(elemento2):#Hacemos un bucle comparando los elementos de los dos arrays que tenemos
            if elemento1[i] < elemento2[j]:
                array_ordenado.append(elemento1[i])
                i += 1
            elif elemento2[j] < elemento1[i]:
                array_ordenado.append(elemento2[j])
                j += 1
        
        #Podemos poner los extends ya que cuando los arrays se dividen la longitud del primero es N, y la longitud del segundo será N o N + 1, entonces como el array ya está ordenado se utiliza el extend para poner el elemento que falta al final.(El extend es un poco más eficiente que el append porque copia el bloque).
        
        array_ordenado.extend(elemento1[i:])
        array_ordenado.extend(elemento2[j:])
        
        return array_ordenado
    
    def merge_sort(lista):#[1, 6, 2, 8, 4, 3], 1, 1
        
        if len(lista) == 1:#Si quisieramos returnear el elemento se tendría que poner variables left y right y cuando se cumpla left == right, returneamos lista[left]
            return lista#2
        
        mitad = len(lista) // 2#0
        
        mitad_izquierda = merge_sort(lista[0:mitad])#[1, 6]
        mitad_derecha = merge_sort(lista[mitad:])#[2]
        
        array_total = ordenar_array(mitad_izquierda, mitad_derecha)#[1], [6]
        
        return array_total#[1, 6]

    array_resultado = merge_sort(tracks)
        
    return array_resultado


if "__main__" == __name__:
    
    resultado = sort_playlist_by_flow([1, 6, 2, 8, 4, 3])
    
    print(f"Array ordenado: {resultado}")

#Ejercicio de divide y vencerás de DJ con BPM(en el moddle esta explicado como el culo porque el guarro del profe hizo el enunciado con chatGPT)

def sort_playlist_by_flow(tracks, use_energy):#[title, bpm, (int energy)opcional]
    
    def ordenar_array(elemento1, elemento2):  # [("Track1", 128, 50)], [("Track2", 128, 70)]
        
        array_ordenado = []#[1]
        i, j = 0, 0#1, 0
        
        while i < len(elemento1) and j < len(elemento2):#Hacemos un bucle comparando los elementos de los dos arrays que tenemos
            
            #Para que sea más facil de comparar los elementos
            
            a = elemento1[i]
            b = elemento2[j]

            #Comparamos BPM de forma ascendente
            if a[1] < b[1]:
                array_ordenado.append(a)
                i += 1
            elif a[1] > b[1]:
                array_ordenado.append(b)
                j += 1
            else:
                #Los BPM son iguales
                if use_energy:
                    #Aqui comparamos la energía de forma descendiente
                    if a[2] > b[2]:
                        array_ordenado.append(a)
                        i += 1
                    elif a[2] < b[2]:
                        array_ordenado.append(b)
                        j += 1
                    else:
                        #Cuando hay empate total se pone la estabilidad primero
                        array_ordenado.append(a)
                        i += 1
                else:
                    #Cuando no hay energía se pone por estabilidad
                    array_ordenado.append(a)
                    i += 1

        #Podemos poner los extends ya que cuando los arrays se dividen la longitud del primero es N, y la longitud del segundo será N o N + 1, entonces como el array ya está ordenado se utiliza el extend para poner el elemento que falta al final.(El extend es un poco más eficiente que el append porque copia el bloque).
        
        array_ordenado.extend(elemento1[i:])
        array_ordenado.extend(elemento2[j:])
        
        return array_ordenado
    
    def merge_sort(lista):#[1, 6, 2, 8, 4, 3], 1, 1
        
        if len(lista) == 1:#Si quisieramos returnear el elemento se tendría que poner variables left y right y cuando se cumpla left == right, returneamos lista[left]
            return lista#2
        
        mitad = len(lista) // 2#0
        
        mitad_izquierda = merge_sort(lista[:mitad])#[("Track1", 128, 50)]
        mitad_derecha = merge_sort(lista[mitad:])#[("Track2", 128, 70)]
        
        array_total = ordenar_array(mitad_izquierda, mitad_derecha)#[1], [6]
        
        return array_total#[1, 6]

    array_resultado = merge_sort(tracks)
        
    return [array_resultado[i][0] for i in range(0, len(array_resultado))]


if "__main__" == __name__:
    
    resultado = sort_playlist_by_flow([("Track1", 120, 10), ("Track2", 120, 10), ("Track3", 120, 9), ("Track4", 119, 1), ("Track5", 121, 5), ("Track6", 120, 10)], use_energy=True)
    
    print(resultado)

#Ejercicio divide y venceras, greedy de las aulas

def solve_mfd_feasible(exams, rooms):
    
    def ordena_array(array1, array2):
        
        array_ordenado = []
        i, j = 0, 0
        while i < len(array1) and j < len(array2):
            
            if array1[i] > array2[j]:
                array_ordenado.append(array1[i])
                i += 1
            else:
                array_ordenado.append(array2[j])
                j += 1
        
        array_ordenado.extend(array1[i:])
        array_ordenado.extend(array2[j:])
        
        return array_ordenado
    
    def dividir_array(lista):
        
        if len(lista) == 1:
            return lista
        
        mitad = len(lista) // 2
        
        izquierdo = dividir_array(lista[:mitad])
        derecha = dividir_array(lista[mitad:])
        
        lista_ordenada = ordena_array(izquierdo, derecha)
        
        return lista_ordenada
    
    def asignar_aulas(examenes, aulas):#[50, 49, 49], [100, 50, 49]
        asignadas = []
        habitaciones_usadas = 0
        
        minima_longitud = min(len(examenes), len(aulas))
        
        for i in range(0, minima_longitud):
            if aulas[i] >= examenes[i]:
                asignadas.append(aulas[i])
                habitaciones_usadas += 1
        
        perdida = sum(asignadas) - sum(examenes_ordendos)
        
        if perdida < 0:
            return "ERROR"
        
        return asignadas, habitaciones_usadas, perdida
    
    examenes_ordendos = dividir_array(exams)
    habitaciones_ordenadas = dividir_array(rooms)
    
    indices_origniales = [i for i, _ in sorted(enumerate(exams), key=lambda x: -x[1])]
    
    if asignar_aulas(examenes_ordendos, habitaciones_ordenadas) == "ERROR":
        return None
    
    aulas_asignadas, aulas_llenas, waste = asignar_aulas(examenes_ordendos, habitaciones_ordenadas)
    
    habitaciones_asignadas = [-1]*len(indices_origniales)
    
    i = 0
    for indice in indices_origniales:
        habitaciones_asignadas[indice] = habitaciones_ordenadas[i]
        i += 1
    
    return aulas_llenas, waste, habitaciones_asignadas


if "__main__" == __name__:
    
    habitaciones_usadas, perdida, habitaciones_asignadas = solve_mfd_feasible([50, 49, 49], [100, 50, 49])
    
    print(f"rooms_used={habitaciones_usadas} waste={perdida}")
    print(f"assign={habitaciones_asignadas}")

#(OPCIONAL) obtener el valor maximo de un array con divide y venceras

def maximo_array(array):
    
    def dividir_array(lista, izq, der):
        
        if izq == der:
            return lista[izq]
        
        mitad = (izq + der) // 2
        
        elemento_izq = dividir_array(lista, izq, mitad)#[2, 5, 8]
        elemento_der = dividir_array(lista, mitad + 1, der)#[9, 4]
        
        if elemento_izq > elemento_der:
            return elemento_izq
        
        return elemento_der 

    maximo = dividir_array(array, 0, len(array) - 1)
    
    return maximo


if "__main__" == __name__:
    
    resultado = maximo_array([2, 5, 8, 9, 4])
    
    print(f"El valor máximo del array es {resultado}")


#(OPCIONAL) obtener todos los elementos repetidos con divide y venceras

def maximo_array(array):
    
    def dividir_array(lista, izq, der, visited):
        
        if izq == der:
            return {lista[izq]}, set()
        
        mitad = (izq + der) // 2
        
        vistos_izquierda, repetidos_izquierda = dividir_array(lista, izq, mitad, visited)#{1, 2, 3}, {1}
        vistos_derecha, repetidos_derecha = dividir_array(lista, mitad + 1, der, visited)#{7, 8, 3}, {}
        
        #El & es una interseccion: {1, 2, 3} & {3, 4, 5} = {3}, y | es unión: {1, 2, 3} | {3, 4, 5} = {1, 2, 3, 4, 5}
        #El & devuelve los elementos que están en ambos conjuntos, mientras que | devuelve los elementos de ambos conjuntos pero sin repetición.
        
        vistos_totales = vistos_izquierda | vistos_derecha#{1, 2, 3, 7, 8}
        repetidos_totales = repetidos_izquierda | repetidos_derecha | (vistos_izquierda & vistos_derecha)#{1, 3}
        
        return vistos_totales, repetidos_totales#{1, 2, 3, 7, 8}, {1, 3}

    vistos, repetidos = dividir_array(array, 0, len(array) - 1, set())#{1, 2, 3, 7, 8}, {1, 3}
    
    return list(repetidos)#[1, 3]


if "__main__" == __name__:
    
    resultado = maximo_array([1, 2, 1, 3, 7, 8, 3])
    
    print(f"Los elementos repetidos son {resultado}")

#(OPCIONAL) ver cuantas veces se repite un elemento x en el array hecho con divide y venceras

def maximo_array(array, x):
    
    def dividir_array(lista, izq, der):
        
        if izq == der:
            if lista[izq] == x:
                return 1
            
            return 0
        
        mitad = (izq + der) // 2
        
        total_izq = dividir_array(lista, izq, mitad)#1
        total_der = dividir_array(lista, mitad + 1, der)#2
        
        return total_izq + total_der

    total = dividir_array(array, 0, len(array) - 1)
    
    return total


if "__main__" == __name__:
    
    resultado = maximo_array([1, 2, 2, 2, 3, 4], 2)
    
    print(f"Los elementos repetidos son {resultado}")

#(OPCIONAL) mostrar todos los elementos del array con divide y venceras

def maximo_array(array):
    
    def dividir_array(lista, izq, der):
        
        if izq == der:
            print(lista[izq])
            
            return lista[izq]
        
        mitad = (izq + der) // 2
        
        elemento_izq = dividir_array(lista, izq, mitad)#[2, 5, 8]
        elemento_der = dividir_array(lista, mitad + 1, der)#[9, 4]
        
        return 0#Por poner algo

    dividir_array(array, 0, len(array) - 1)
    
    return "Elementos del array mostrados."


if "__main__" == __name__:
    
    resultado = maximo_array([1, 2, 1, 3, 7, 8, 3])
    
    print(resultado)

#(OPCIONAL) Ejercicio de contar las inversiones de un array, HECHO POR CHATGPT(PORQUE EL EJERCICIO ERA JODIDO)

def maximo_array(array):
    
    def contar_inversiones(array_izq, array_der):#Recibe los arrays ordenados asi es mas facil de encontrar los invertidos.
        inversiones = []
        i, j = 0, 0
        merged = []

        while i < len(array_izq) and j < len(array_der):
            if array_izq[i] <= array_der[j]:
                merged.append(array_izq[i])
                i += 1
            else:
                merged.append(array_der[j])
                # Todos los elementos restantes en array_izq son mayores → inversiones
                for k in range(i, len(array_izq)):
                    inversiones.append((array_izq[k], array_der[j]))
                j += 1

        # Añadir los elementos restantes
        merged.extend(array_izq[i:])
        merged.extend(array_der[j:])

        return merged, inversiones, len(inversiones)
    
    def dividir_array(lista):
        if len(lista) <= 1:
            return lista, [], 0
        
        mitad = len(lista) // 2
        
        lista_izquierda, inv_izq, total_izq = dividir_array(lista[:mitad])
        lista_derecha, inv_der, total_der = dividir_array(lista[mitad:])
        
        lista_total, inv_cruzadas, total_cruzadas = contar_inversiones(lista_izquierda, lista_derecha)

        # Sumar todas las inversiones (izquierda + derecha + cruzadas)
        inversiones_totales = inv_izq + inv_der + inv_cruzadas
        total_inversiones = total_izq + total_der + total_cruzadas

        return lista_total, inversiones_totales, total_inversiones

    _, inversiones, total_inversiones = dividir_array(array)
    
    return inversiones, total_inversiones


if __name__ == "__main__":
    inversiones, total_inversiones = maximo_array([2, 4, 1, 3, 5])
    print(f"Los elementos invertidos son {inversiones}, y son un total de {total_inversiones} inversiones.")

#(OPCIONAL) Devolver el número total de elementos que son mayores que n con divide y venceras

def mayores_que_n(array, n):
    
    def comprobar_elementos(array1, array2):#Si n es impar entonces un array tendrá longitud n/2, y el otro (n/2) + 1(porque los dividimos por las mitades), pero si n es par los dos arrays tendrán longitud n/2.
        i, j = 0, 0#0, 0
        mayores_que = []#[]
        minima_longitud = min(len(array1), len(array2))#Esto devuelve la longitud mas pequeña de las longitudes de los dos arrays.
        
        while i < minima_longitud and j < minima_longitud:#Que vayan los índices hasta la logitud minima.
            
            if array1[i] > n:
                mayores_que.append(array1[i])
            
            i += 1
            
            if array2[j] > n:
                mayores_que.append(array2[j])
            
            j += 1
        
        if len(array1) > minima_longitud:#Y ya se compara el elemento que falta del array que tiene la longitud más larga, si los dos arrays tienen la misma longitud estas condiciones no se ejecutan.
            if array1[i] > n:
                mayores_que.append(array1[i])
        elif len(array2) > minima_longitud:
            if array2[j] > n:
                mayores_que.append(array2[j])
        
        return mayores_que
    
    def dividir_array(lista):
        
        if len(lista) <= 1:
            return lista
            
        mitad = len(lista) // 2
        
        izquierda = dividir_array(lista[:mitad])#3
        derecha = dividir_array(lista[mitad:])
        
        lista_mayores_que_n = comprobar_elementos(izquierda, derecha)
        
        return lista_mayores_que_n
    
    numeros_mayores_que_n = dividir_array(array)
    
    return numeros_mayores_que_n
    

if "__main__" == __name__:
    
    lista = [3, 2, 9, 6, 3, 4]
    n = 5
    
    resultado = mayores_que_n(lista, 5)
    
    print(f"Los numeros mayores que {n} son {resultado}.")

#(OPCIONAL) Igual que el ejercicio de arriba pero de una forma mas facil de entender.

def mayores_que_n(array, n):
    # Caso base
    if len(array) == 0:
        return []
    elif len(array) == 1:
        return [array[0]] if array[0] > n else []

    # Dividir
    mitad = len(array) // 2
    izquierda = array[:mitad]
    derecha = array[mitad:]

    # Conquistar (recursivamente)
    mayores_izquierda = mayores_que_n(izquierda, n)
    mayores_derecha = mayores_que_n(derecha, n)

    # Combinar resultados
    return mayores_izquierda + mayores_derecha


if __name__ == "__main__":
    lista = [3, 2, 9, 6, 3, 4]
    n = 5
    resultado = mayores_que_n(lista, n)
    print(f"Los números mayores que {n} son {resultado}.")

#(OPCIONAL) Devolver el número total de elementos que son mayores que n y la longitud del array final con divide y venceras

def mayores_que_n(array, n):
    
    def comprobar_elementos(array1, array2):#Si n es impar entonces un array tendrá longitud n/2, y el otro (n/2) + 1(porque los dividimos por las mitades), pero si n es par los dos arrays tendrán longitud n/2.
        i, j = 0, 0#0, 0
        mayores_que = []#[]
        minima_longitud = min(len(array1), len(array2))#Esto devuelve la longitud mas pequeña de las longitudes de los dos arrays.
        
        while i < minima_longitud and j < minima_longitud:#Que vayan los índices hasta la logitud minima.
            
            if array1[i] > n:
                mayores_que.append(array1[i])
            
            i += 1
            
            if array2[j] > n:
                mayores_que.append(array2[j])
            
            j += 1
        
        if len(array1) > minima_longitud:#Y ya se compara el elemento que falta del array que tiene la longitud más larga, si los dos arrays tienen la misma longitud estas condiciones no se ejecutan.
            if array1[i] > n:
                mayores_que.append(array1[i])
        elif len(array2) > minima_longitud:
            if array2[j] > n:
                mayores_que.append(array2[j])
        
        return mayores_que
    
    def dividir_array(lista):
        
        if len(lista) <= 1:
            return lista
            
        mitad = len(lista) // 2
        
        izquierda = dividir_array(lista[:mitad])#3
        derecha = dividir_array(lista[mitad:])
        
        lista_mayores_que_n = comprobar_elementos(izquierda, derecha)
        
        return lista_mayores_que_n
    
    numeros_mayores_que_n = dividir_array(array)
    
    return numeros_mayores_que_n
    

if "__main__" == __name__:
    
    lista = [3, 2, 9, 6, 3, 4]
    n = 5
    
    resultado = mayores_que_n(lista, 5)
    
    print(f"Los numeros mayores que {n} son {resultado}.")

#Problema de la mochila con Branch and Bound(En el Moddle no saben explicar los HEDIONDOS)

from collections import namedtuple

Item = namedtuple("Item", ['index', 'value', 'weight'])

class Node:
    def __init__(self, index, taken, value, room):
        self.index = index
        self.taken = taken
        self.value = value
        self.room = room
        return

    def estimate(self, items, weights):
        bound = self.value #Valor actual del nodo, 0
        peso = self.room #Espacio actual del nodo, 10
        for i in range(self.index, len(items)):#1, 2
            peso -= weights[i]
            bound += items[i]
        return bound

def solve_branch_and_bound_DFS(capacity, items, record_visiting_order = False):
    """"
    :param capacity: capacidad de la mochila
    :param items: items de la mochila
    :param record_visiting_order: activa/desactiva el registro de nodos visitados
    :return: Por ahora sólo devuelve la lista de nodos visitados
    """
    values = []
    weights = []
    for i in range(0, len(items)):
        u, v, w = items[i]
        values.append(v)
        weights.append(w)
    
    #Si nos pidieran el mejor valor esto si se pondría
    
    best_value = 0
    best_taken = []
    
    ##################################################

    # Completa este código para realizar el recorrido DFS; tienes
    # indicados los sitios que debes completar con tres puntos
    # suspensivos ("...")

    # Utilizamos la lista 'alive' como nuestra pila de nodos vivos
    # (pendientes de visitar) para programar nuestro recorrido DFS.
    
    alive = []
    
    # Utilizamos la lista Visiting_Order como el registro de nodos
    # visitados (el contenido final de esta lista lo utiliza el VPL
    # para comprobar que nuestro recorrido DFS es correcto).

    visiting_order = []

    # 1) Creamos el nodo raiz (en este VPL todavía no utilizamos los
    #    parámetros taken, value, room, con lo que se inicializan con
    #    lista vacía y 0). El único valor necesario en el nodo es el
    #    indice al primer elemento de la lista (index = 0).
    # ...
    nodo_raiz = Node(0, [], 0, capacity)
    
    if not isinstance(record_visiting_order, set):
        record_visiting_order = set()

    # Lo añadimos a la lista de nodos vivos (alive)
    # ...
    alive.append(nodo_raiz)

    # Mientras haya nodos en la lista de nodos vivos
    # ...
    while len(alive) != 0:#[0, 1, 2,]
                          #[1I, 2I, ]
        
        # Avanzamos al siguiente nodo de nuestro recorrido DFS (hacemos un pop
        # de la lista) y lo registramos en nuestro recorrido DFS.

        current_node = alive.pop()##Nodo raiz
        
        if current_node not in record_visiting_order:
            record_visiting_order.add(current_node)
        
        visiting_order.append(current_node.index)
        
        #En este caso no te esta pidiendo el mojer valor o la mejor combinacion, sino que recorras el árbol completo entonces quitamos la poda.
        
        if current_node.room <= 0:
            continue
        
        #El método estimate lo que hace es devolver el valor máximo posible de la rama que estamos mirando, entonces si ese valor es más pequeño que el mejor valor actual no vale la pena seguir mirando la rama y se poda
        
        if current_node.estimate(values, weights) < best_value:
            continue
        
        #No buscamos el mejor valor, ya que no hay poda
        
        if current_node.value > best_value:
            best_value = current_node.value
            best_taken = current_node.taken
        
        ###############################################

        # Si no hemos llegado al final del árbol
        #    1) Ramificamos (branch) por la derecha (append)
        #    2) Ramificamos (branch) por la izquierda (append)
        # ...
        if current_node.index < len(items):
            taken_left = current_node.taken.copy()
            taken_left.append(current_node.index)
            nodo_izquierdo = Node(current_node.index + 1, taken_left, current_node.value + values[current_node.index], current_node.room - weights[current_node.index])#[1, [1, ], ]
            nodo_derecho = Node(current_node.index + 1, current_node.taken.copy(), current_node.value, current_node.room)
            alive.append(nodo_derecho)
            alive.append(nodo_izquierdo)

    #Esta sería la solución viable si te piden el mejor valor, pero solote piden el visiting_order completo del árbol.
    
    return best_value, [i + 1 for i in best_taken], visiting_order
    
    #Como los dos primeros parámetros dan igual pues ponemos lo que sea y devolvemos el visiting_order sin poda
    
    #return 0, [], visiting_order


if "__main__" == __name__:
    
    resultado = solve_branch_and_bound_DFS(10, [(0, 45, 5), (1, 48, 8), (2, 35, 3), (3, 55, 3), (4, 15, 7)], set())
    
    print(resultado)

#(OPCIONAL) Fibonacci hecho con memorization

def fibonacci(n):
    
    memo = {}
    
    def memorization(n):
        
        if n in memo:
            return memo[n]
        elif n <= 0:
            memo[n] = 0
            return 0
        elif n == 1:
            memo[1] = 1
            return 1
        else:
            memo[n] = memorization(n-1) + memorization(n-2)
        return memo[n]

    memorization(n)
    return memo


if "__main__" == __name__:
    
    resultado = fibonacci(5)
     
    print(resultado) 

#(OPCIONAL) Calcular el factorial de un numero con memorization, un poco inutil porque los subproblemas no se repiten

def memix(n):
    
    memo = {}
    
    def memorization(n):
        
        if n in memo:
            return memo[n]
        elif n <= 1:
            memo[n] = 1
            return 1
        else:
            memo[n] = n * memorization(n - 1)
        return memo[n]
        
    return memorization(n)


if "__main__" == __name__:
    
    resultado = memix(5)
     
    print(resultado) 

#(OPCIONAL) Número de los posibles caminos en una cuadrícula con memorization, es mas facil de lo que parece.

def memix(m, n):
    
    memo = {}
    
    def memorization(m, n):
        
        if (m, n) in memo:
            return memo[(m, n)]
        elif m == 0:
            memo[(0, n)] = 1
            return 1
        elif n == 0:
            memo[(m, 0)] = 1
            return 1
        else:
            memo[(m, n)] = memorization(m - 1, n) + memorization(m, n - 1)
            return memo[(m, n)] 
        
    return memorization(m, n)


if "__main__" == __name__:
    
    resultado = memix(2, 2)
     
    print(resultado) 

#(OPCIONAL) Ejercicio de cortar una barilla de metal y obtener la maxima ganacia posible

def memix(longitud, precios):
    
    memo = {}
    
    def memorization(longitud):#3
        
        if longitud in memo:
            return memo[longitud]
        elif longitud == 0:
            return 0
        
        max_ganancia = 0
        for i in range(1, longitud + 1):
            ganancia = precios[i - 1] + memorization(longitud - i)
            max_ganancia = max(max_ganancia, ganancia)#8
        memo[longitud] = max_ganancia
        return memo[longitud]
        
    return memorization(longitud)


if "__main__" == __name__:
    
    precios = [1, 5, 8, 9]
    resultado = memix(4, precios)
     
    print(resultado) 

#(OPCIONAL) Ejercicio de calcular maneras posibles de llegar a la cima

def memix(n):
    
    memo = {}
    
    def memorization(escalones):#3
        
        if escalones in memo:
            return memo[escalones]
        elif escalones == 0:
            return 1
        elif escalones < 0:
            return 0
        else:
            memo[escalones] = memorization(escalones - 1) + memorization(escalones - 2)
        return memo[escalones]
        
    return memorization(n)


if "__main__" == __name__:
    
    resultado = memix(6)
     
    print(resultado) 

#(OPCIONAL) Problema de devolver el número de monedas meínimas para llegar al valor n

def memix(cantidad, monedas):
    
    memo = {}
    
    def memorization(cantidad):
        
        if cantidad in memo:
            return memo[cantidad]
        elif cantidad == 0:
            return 0
        elif cantidad < 0:
            return 99999#Ponemos un valor super grande porque si el valor es diferente de cero significa que las monedas no dan exactas
        
        minima_cantidad = 999
        for i in range(len(monedas)):
            cantidad_monedas = 1 + memorization(cantidad - monedas[i])#Sumamos uno ya que si da bien significa que hemos cogido una moneda
            minima_cantidad = min(minima_cantidad, cantidad_monedas)

        memo[cantidad] = minima_cantidad
        return memo[cantidad]
        
    return memorization(cantidad)


if "__main__" == __name__:
    
    monedas = [1, 3, 4]
    resultado = memix(6, monedas)
     
    print(resultado) 
    
#(OPCIONAL) Mismo problema que arriba pero solo devuelve la primera combinacion más pequeña que encuentra

def memix(cantidad, monedas):
    memo = {}

    def memorization(cantidad):
        if cantidad in memo:
            return memo[cantidad]
        if cantidad == 0:
            return 0, []
        if cantidad < 0:
            return float('inf'), []

        min_monedas = float('inf')
        mejor_lista = []

        for m in monedas:
            n_monedas, lista = memorization(cantidad - m)#2, [3, 3]
            if n_monedas + 1 < min_monedas:
                min_monedas = n_monedas + 1
                mejor_lista = lista + [m]

        memo[cantidad] = (min_monedas, mejor_lista)
        return memo[cantidad]

    return memorization(cantidad)


if __name__ == "__main__":
    monedas = [3, 2, 4]
    resultado = memix(6, monedas)
    print(resultado)

#(OPCIONAL) Mismo problema que arriba pero ahora devuelve todas las combinaciones con la misma lognitud que la longitud de la minima combiancion:

def memix(cantidad, monedas):
    
    memo = {}

    def memorization(cantidad):
        if cantidad in memo:
            return memo[cantidad]
        if cantidad == 0:
            return 0, [[]]
        if cantidad < 0:
            return float('inf'), []

        minima_cantidad = float('inf')
        combinaciones_minimas = []

        for m in monedas:
            cantidad_monedas, combinaciones = memorization(cantidad - m)

            if cantidad_monedas == float('inf'):
                continue

            for combo in combinaciones:
                nueva = combo + [m]
                if cantidad_monedas + 1 < minima_cantidad:
                    minima_cantidad = cantidad_monedas + 1
                    combinaciones_minimas = [nueva]
                elif cantidad_monedas + 1 == minima_cantidad:
                    combinaciones_minimas.append(nueva)

        memo[cantidad] = (minima_cantidad, combinaciones_minimas)
        return memo[cantidad]

    return memorization(cantidad)


if "__main__" == __name__:
    
    monedas = [3, 2, 4]
    resultado = memix(6, monedas)
     
    print(resultado) 

#Examen del año pasado, tercer parcial, encontrar el sendero con el peso minimo en un grafo dirigido aciclico

import networkx as nx

def build_graph(input_list):
    
    nodos_vistos = set()
    grafo = nx.DiGraph()
    
    for element in input_list:
        u, v, w = element
        if u not in nodos_vistos:
            nodos_vistos.add(u)
        elif v not in nodos_vistos:
            nodos_vistos.add(v)
        grafo.add_edge(u, v, weight=w)
    
    for nodo in nodos_vistos:
        grafo.add_node(nodo)
    
    return grafo


def solve(grafo, from_node, to_node):
    
    memo = {}
    
    def memix(grafo, from_node, to_node):
        if to_node in memo:
            return memo[to_node]
        elif to_node == from_node:
            return 0, [to_node]
        
        sendero_minimo = []
        peso_minimo = float('inf')
        for predecesor in grafo.predecessors(to_node):#to_node=1, predecesor=7
            peso_total, sendero = memix(grafo, from_node, predecesor)#0, [7]
            if peso_total + grafo[predecesor][to_node]['weight'] < peso_minimo:
                peso_minimo = peso_total + grafo[predecesor][to_node]['weight']
                sendero_minimo = sendero + [to_node]
        
        memo[to_node] = (peso_minimo, sendero_minimo)#[1, [7, 1]]
        return memo[to_node]
    
    return memix(grafo, from_node, to_node)


if __name__ == "__main__":
    
    input_list = [(7, 1, 1), (7, 3, 2), (7, 5, 5), (1, 2, 4), (1, 4, 3), (3, 2, 9), (3, 4, 5), (3, 6, 16), (5, 6, 22), (2, 8, 18), (4, 8, 13), (6, 8, 2)]
    grafo = build_graph(input_list)
    resultado = solve(grafo, 7, 8)
    print(resultado)

#Mochila hecho con memorization

def solve(pesos, valores, capacity):
    
    memo = {}
    
    #En el codigo en general la unica clave es capacity, entonces si hay dos subproblema con la misma capacity se quedara con el primero que vio, entonces para solucionar esto he comantado las partes en donde hay que cambiar una cosa para que esto no pase, yo no lo he hecho porque es mas entendible asi.
    
    def memix(pesos, valores, capacity, contador):
        if capacity in memo:#Aqui para solcuionar lo del problema del subproblema seria: if (capacity, contador) in memo:
            return memo[capacity]                                                           #return memo[(capacity, contador)]
        elif capacity == 0:
            return 0, []
        elif capacity < 0:
            return float('-inf'), []
        
        objetos_cogidos = []
        valor_maximo = -999
        for i in range(contador, len(pesos)):
            valor, objetos = memix(pesos, valores, capacity - pesos[i], i + 1)#6
            if valor + valores[i] > valor_maximo:
                valor_maximo = valor + valores[i]
                objetos_cogidos = objetos + [valores[i]]
        
        memo[capacity] = (valor_maximo, objetos_cogidos)#Aqui para solcuionar lo del problema del subproblema seria: memo[(capacity, contador)] = (valor_maximo, objetos_cogidos)
        return memo[capacity]                                                                                       #return memo[(capacity, contador)]
        
    return memix(pesos, valores, capacity, 0)     


if __name__ == "__main__":
    
    pesos = [2, 3, 4, 5]
    valores = [3, 4, 5, 8]
    resultado = solve(pesos, valores, 8)
    print(resultado)

#El problema de arriba para que no ocurra el error de los subproblema seria asi

def solve(pesos, valores, capacity):
    
    memo = {}
    
    def memix(pesos, valores, capacity, contador):
        if (capacity, contador) in memo:
            return memo[(capacity, contador)]
        elif capacity == 0:
            return 0, []
        elif capacity < 0:
            return float('-inf'), []
        
        #En este problema si que hay bucle porque desde cualquier objeto tienes que ver las combianciones con el resto, ya que varias combinaciones son solo cogiendo el objeto 1, o el objeto 2 o el objeto n
        
        objetos_cogidos = []
        valor_maximo = -999
        for i in range(contador, len(pesos)):
            valor, objetos = memix(pesos, valores, capacity - pesos[i], i + 1)
            if valor + valores[i] > valor_maximo:
                valor_maximo = valor + valores[i]
                objetos_cogidos = objetos + [valores[i]]
        
        memo[(capacity, contador)] = (valor_maximo, objetos_cogidos)
        return memo[(capacity, contador)]
        
    return memix(pesos, valores, capacity, 0)     


if __name__ == "__main__":
    pesos = [2, 3, 4, 5]
    valores = [3, 4, 5, 8]
    resultado = solve(pesos, valores, 8)
    print(resultado)

#Problema del ladron hecho con memorization

def ladron_con_memorization(casas):
    
    memo = {}
    
    def memix(indice):
        
        #En este caso no se pone una condicion cuando el indice supera al len de las casa, porque aqui da igual simplemente se retornea cero porque simplemente no quedan casas por robar, en el de la mochila si se pone porque si te pasas de la capacidad si es un error.
        if indice >= len(casas):
            return 0, []
        
        if indice in memo:
            return memo[indice]
        
        #Aqui no hay bucle porque el indice solo puede ir a indice + 1 o indice + 2, no a cualquier otra casa
        
        # Opción 1: no robar esta casa
        valor_no, casas_no = memix(indice + 1)
        
        # Opción 2: sí robar esta casa
        valor_si, casas_si = memix(indice + 2)
        valor_si += casas[indice]
        
        if valor_si > valor_no:
            resultado = (valor_si, casas_si + [indice])
        else:
            resultado = (valor_no, casas_no)
        
        memo[indice] = resultado
        return memo[indice]      
    
    valor, casas_robadas = memix(0)
    casas_robadas.reverse()
    return valor, casas_robadas


if __name__ == "__main__":
    
    casas = [3, 10, 3, 1, 2]
    resultado = ladron_con_memorization(casas)
    
    print(resultado)

#(OPCIONAL) Ejercicio en donde averiguas el valor de fibonacci en n con tabulation

def fibonacci(n):
    
    def tabulation(n):
        
        lista_fibonacci = [-1]*n#[-1, -1, -1, -1, -1]
        
        if n == 1:
            return 0
        elif n == 2:
            return 1
        
        lista_fibonacci[0] = 0
        lista_fibonacci[1] = 1
        
        for i in range(2, len(lista_fibonacci)):#i=3
            lista_fibonacci[i] = lista_fibonacci[i - 1] + lista_fibonacci[i - 2]
        
        return lista_fibonacci[n - 1]
    
    return tabulation(n)


if __name__ == "__main__":

    resultado = fibonacci(5)
    print(resultado)

#(OPCIONAL) Formas de llegar a un n escalon pudiendo saltar 1 o dos escalones con tabulation

def escalones(n):
    
    def tabulation(n):
        
        lista_escalones = [-1]*n#[-1, -1, -1, -1, -1]
        
        if n == 1:
            return 1
        elif n == 2:
            return 2
        
        lista_escalones[0] = 1
        lista_escalones[1] = 2
        
        for i in range(2, len(lista_escalones)):#i=3
            lista_escalones[i] = lista_escalones[i - 1] + lista_escalones[i - 2]
        
        return lista_escalones[n - 1]
    
    return tabulation(n)


if __name__ == "__main__":

    resultado = escalones(5)
    print(resultado)

#(OPCIONAL) Problema de llegar de un punto a otro de una cuadricula con tabulation

def cuadricula(m, n):#En este ejercicio solo podemos ir a la derecha o abajo
    
    def tabulation(m, n):
        
        cuadricula_hecha = []
        
        for i in range(m):
            if i == 0:
                cuadricula_hecha.append([1]*n)#Aqui en la primera fila de la cuadricula se pone uno ya que solo hay un camino posible que es a la derecha
            else:
                fila_cuadricula = [1] + [-1]*(n - 1)#Aqui se pone el primer elemento de las filas 1 ya que solo hay un posible camino que es ir hacia abajo
                cuadricula_hecha.append(fila_cuadricula)
        
        if m == 1 and n == 1:
            return 1
        
        for i in range(1, m):
            for j in range(1, n):
                cuadricula_hecha[i][j] = cuadricula_hecha[i - 1][j] + cuadricula_hecha[i][j - 1]
        
        return cuadricula_hecha[m - 1][n - 1]
    
    return tabulation(m, n)


if __name__ == "__main__":

    resultado = cuadricula(3, 3)
    print(resultado)

#(OPCIONAL) Formas de sumar n elementos para llegar a una suma s con tabulation

def subset_sum(numeros, suma):
    
    def tabulation(numeros, suma):
        
        tabla_hecha = []
        
        tabla_hecha = [[0]*(suma+1) for _ in range(len(numeros)+1)]
        tabla_hecha[0][0] = 1
        
        #Las filas de la tabla son el numero de elementos que estamos utilizando de la lista para llegar a la suma
        #Las columnas son las sumas idoneas antes de llegar a la suma final
        
        for i in range(1, len(numeros) + 1):
            for j in range(0, suma + 1):
                tabla_hecha[i][j] = tabla_hecha[i - 1][j]
                if j >= numeros[i - 1]:
                    tabla_hecha[i][j] += tabla_hecha[i - 1][j- numeros[i - 1]]
                
        return tabla_hecha[len(numeros)][suma]
    
    return tabulation(numeros, suma)


if __name__ == "__main__":

    resultado = subset_sum([1, 2, 3], 4)
    print(resultado)

#(OPCIONAL) Problema de contar los posibles caminos hasta una posicion m x n, y ver posiciones por matriz, 0 es libre 1 es obstáculo con tabulation
#Explicación porque se pone una fila y una columna extra en la carpeta de Cosas importantes AP

def cuadricula_con_obstaculo(matriz):
    
    def tabulation(matriz):
        
        m = len(matriz)#Filas de la matriz
        n = len(matriz[0])#Columnas de la matriz
        
        cuadricula_hecha = [[0]*(n + 1) for _ in range(m + 1)]#Se pone una columna y una fila extra de ceros para que la formula funcione desde el caso más básico, además se pone primero la n, ya que por cada fila(m) se crean (n)columnas
        
        #Se pone este caso base porque si empezamos desde la columna o fila de ceros añadida podemos ir abajo o a la derecha y cuenta como 1(si no es obstáculo)
        #Además también se pone el caso base para que los futuros valores de las futuras posiciones que se crean con la fórmula funcionen gracias a tener el caso más básico
        cuadricula_hecha[1][1] = 1 if matriz[0][0] == 0 else 0
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                
                #Este es el caso base que ya se puso antes así que nos lo saltamos
                if i == 1 and j == 1:
                    continue
                
                if matriz[i - 1][j - 1] == 0:
                    cuadricula_hecha[i][j] = cuadricula_hecha[i - 1][j] + cuadricula_hecha[i][j - 1]
                elif matriz[i - 1][j - 1] == 1:
                    cuadricula_hecha[i][j] = 0
        
        #Returneamos el valor de la esquina inferior derecha(el último lugar por ver de la cuadricula)
        return cuadricula_hecha[m][n]
    
    return tabulation(matriz)


if __name__ == "__main__":
    
    matriz = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]
    resultado = cuadricula_con_obstaculo(matriz)
    
    print(resultado)

#Problema de la mochila con tabulation, devolviendo los objetos que cogimos

def mochila_con_tabulation(pesos, valores, capacidad):
    
    #En tabulation, es parecido a memorization, cada hueco en la tabla es el valor máximo posible que podemos obtener con i objetos y capacidad j
    
    def tabulation(pesos, valores, capacidad):
        
        n = len(pesos)
        
        tabla_hecha = [[0]*(capacidad + 1) for _ in range (n + 1)]
        
        #La i trata de ser el valor máximo posible cogiendo el objeto n, y nos apoyamos cogiendo la fila anterior que es el valor máximo de todos los pesos[0, capacidad_maxima] del objeto n - 1
        
        for i in range(1, n + 1):#2, i ----> Número de objetos
            for j in range(1, capacidad + 1):#3, j ----> Capacidad máxima
                if pesos[i - 1] <= j:#Ponemos pesos[i - 1], porque como empieza en 1, y los pesos van de 0 hasta n, si queremos empezar por el primero i = 1 - 1 = 0
                    #La j hace como el valor actual de la capacidad máxima que va de 0 hasta n, donde n es la capacidad
                    tabla_hecha[i][j] = max(tabla_hecha[i - 1][j], tabla_hecha[i - 1][j - pesos[i - 1]] + valores[i - 1])#Cuando hacemos [j - pesos[i - 1]], estamos devolviendo el valor maximo posible con ese peso, y luego se lo sumamos al valor para saber si en el lugar donde estamos hay un mejor valor
                else:
                    tabla_hecha[i][j] = tabla_hecha[i - 1][j]
        
        #Para saber que objetos cogimos
        
        i = n
        j = capacidad
        objetos_cogidos = []
        
        while i > 0 and j > 0:
            #Esta en la mochila
            if tabla_hecha[i][j] != tabla_hecha[i - 1][j]:#Si el objeto de la fila anterior no es igual que el objeto de la fila actual significa que el valor máximo es otro, entonces hemos cogido el objeto.
                objetos_cogidos.append(i - 1)
                i = i - 1
                j = j - pesos[i]
            else:
                #No esta en la mochila
                i = i - 1#Hacemos i - 1, ya que estamos mirando los objetos, si hicieramos j - 1 estaríamos mirando los pesos.
        
        objetos_cogidos.reverse()
        
        return tabla_hecha[n][capacidad], objetos_cogidos
    
    return tabulation(pesos, valores, capacidad)


if __name__ == "__main__":
    
    pesos = [1, 2, 3, 4]
    valores = [3, 4, 5, 7]
    resultado = mochila_con_tabulation(pesos, valores, 5)
    
    print(resultado)

#Problema del ladrón con tabulation, devuelve el valor máximo y las casa robadas

def ladron_con_tabulation(casas):
    
    #Hay también que entender, que todos los problema de tabulation no constan de dos variables
    
    def tabulation(casas):
        
        n = len(casas)
        
        tabla_hecha = (n + 1)*[0]
        
        #Caso base, se puede hacer también así
        #tabla_hecha[1] = tabla_hecha[0]+ casas[0]
        
        for i in range(1, n + 1):#3
            if i <= 1:
            #También el caso base se puede hacer así
                tabla_hecha[i] = tabla_hecha[i - 1] + casas[i - 1]#Como en el problema del ladrón pudes robar dos casas delantes de la que robastes, pues tendríamos que poner dos casos base como fibonacci
            else:
                tabla_hecha[i] = max(tabla_hecha[i - 2] + casas[i - 1], tabla_hecha[i - 1])#Hacemos el máximo entre no robar la siguiente casa y quedarnos con el valor robando la casa anterior, o no robamos la casa actual y robamos la anterior
        
        #Este bucle se asegure de que no reobes dos casa consecutivas ya que si coges la opcion de tabla_hecha[i - 2] + casas[i - 1], signiifca que robastes dos casas antes, y si coges la otra opcion tabla_hecha[i - 1] significa que robastes la anterior casa
        
        casas_robadas = []
        i = n

        while i > 0:
            # Si no robaste la casa i
            if tabla_hecha[i] == tabla_hecha[i - 1]:
                i -= 1
            else:
                # Si robaste la casa i
                casas_robadas.append(i - 1)   # guardamos el índice real de la casa
                i -= 2

        casas_robadas.reverse()
        
        return tabla_hecha[n], casas_robadas
    
    return tabulation(casas)


if __name__ == "__main__":
    
    casas = [3, 10, 3, 1, 2]
    resultado = ladron_con_tabulation(casas)
    
    print(resultado)

#Ejercicio de hacer la tabla de pascal y calcula cuantos equipos con la formula de las permutaciones con tabulation(La funcion build_pascal_table, literalmente no sirve para nada).

def tabla_paskilx(n, k):
    
    def factorial(a):
        
        if a <= 0:
            return 1
        else:
            return a * factorial(a - 1)
    
    def build_pascal_table(n, k):
        
        tabla_hecha = [[1]*(i + 1) for i in range(k + 1)]
        
        tabla_hecha = tabla_hecha + [[1]*(k + 1) for _ in range(k + 1, n + 1)]
        
        return tabla_hecha
    
    def solve_project_teams(n, k):
        
        tabla = [[1]*(i + 1) for i in range(k + 1)]
        
        tabla = tabla + [[1]*(k + 1) for _ in range(k + 1, n + 1)]
        
        for i in range(1, n + 1):
            for j in range(1, len(tabla[i])):
                tabla[i][j] = int(factorial(i)/(factorial(j)*(factorial(i - j))))
        
        return tabla[n][k], tabla
    
    build_pascal_table(n, k)
    
    return solve_project_teams(n, k)


if __name__ == "__main__":
    
    teams, table = tabla_paskilx(10, 3)
    
    print(f"Teams={teams}")
    print("DP_Table:")
    for i, row in enumerate(table):
        print("row {}: {}".format(i, " ".join(map(str, row))))

#Ejercicio de coloreado de grafos hecho con DSatur

import networkx as nx

def build_graph(input_list):
    
    grafo = nx.Graph()
    nodos_vistos = set()
    
    for arista in input_list:
        u, v = arista
        if u not in nodos_vistos:
            nodos_vistos.add(u)
        elif v not in nodos_vistos:
            nodos_vistos.add(v)
        grafo.add_edge(u, v)
    
    for node in nodos_vistos:
        grafo.add_node(node)
    
    return grafo

def solve_dsat_coloring(graph, order_nodes):

    colors = {}  # nodo → color asignado

    def grado_saturacion(nodo):
        """Cantidad de colores distintos en los vecinos del nodo."""
        return len({colors[v] for v in graph.neighbors(nodo) if v in colors})

    # 1) Seleccionar primer nodo: el de mayor grado
    nodo_inicial = max(order_nodes, key=lambda n: graph.degree(n))
    colors[nodo_inicial] = 0

    # 2) Repetir hasta colorear todos
    while len(colors) < len(graph.nodes()):

        # Nodos no coloreados con su saturación
        nodos_actuales = {
            n: grado_saturacion(n)
            for n in graph.nodes()
            if n not in colors
        }

        # Máxima saturación
        max_sat = max(nodos_actuales.values())

        # Nodos con máxima saturación
        candidatos = [n for n in nodos_actuales if nodos_actuales[n] == max_sat]

        # 2º criterio: mayor grado
        max_grado = max(graph.degree(n) for n in candidatos)
        candidatos = [n for n in candidatos if graph.degree(n) == max_grado]

        # 3º criterio: lexicográfico
        nodo_objetivo = min(candidatos)

        # Asignar color mínimo disponible
        used_colors = {colors[v] for v in graph.neighbors(nodo_objetivo) if v in colors}

        color_minimo = 0
        while color_minimo in used_colors:
            color_minimo += 1

        colors[nodo_objetivo] = color_minimo

    # Retornar colores en el orden pedido
    return [colors[v] for v in order_nodes]


if __name__ == "__main__":
    
    input_list = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]
    grafo = build_graph(input_list)
    resultado = solve_dsat_coloring(grafo, grafo.nodes())
    
    print(resultado)

#(OPCIONAL) Forma de construir todas las permutaciones de un numero N con DFS

def permutaciones_numero(numero):
    
    digitos = [int(element) for element in str(numero)]#[1, 2, 3]
    permutaciones_totales = []#[123, 132]
    
    def dfs(permutacion, indices_usados):#[], {}
        
        if len(permutacion) == len(digitos):
            permutaciones_totales.append(int("".join(map(str, list(permutacion)))))
            return
        
        for i in range(len(digitos)):
            
            if i in indices_usados:
                continue
            
            permutacion.append(digitos[i])
            indices_usados.add(i)
            dfs(permutacion, indices_usados)
            indices_usados.discard(i)
            permutacion.pop()
            
        return
            
    dfs([], set())
    return set(permutaciones_totales)
    
if "__main__" == __name__:
    
    resultado = permutaciones_numero(123)
    print(resultado)

#(OPCIONAL) Mismo ejercicio que arriba pero con yield(menos memoria)

def permutaciones_numero(numero):
    
    digitos = [int(element) for element in str(numero)]#[1, 2, 3]
    
    def dfs(permutacion, indices_usados):#[], {}
        
        if len(permutacion) == len(digitos):
            yield int("".join(map(str, list(permutacion))))#[123, 132]
            return
        
        for i in range(len(digitos)):
            
            if i in indices_usados:
                continue
            
            permutacion.append(digitos[i])
            indices_usados.add(i)
            yield from dfs(permutacion, indices_usados)
            indices_usados.discard(i)
            permutacion.pop()
            
        return
            
    yield from dfs([], set())
    
if "__main__" == __name__:
    
    resultado = permutaciones_numero(123)
    for permutacion in set(resultado):
        print(permutacion)

#(OPCIONAL) Encontrar todas las combinaciones de un numero N hasta un numero M, con longitud G con DFS(basicamente fuerza bruta)

def combinaciones_numero(numero_inicial, numero_final, longitud):#5

    combinaciones_totales = []#[[0, 0, 0, 0], [0, 0, 0, 1] ..... [4, 4, 4, 3], [4, 4, 4, 4]]
    
    def dfs(combinacion):#[]
        
        if len(combinacion) == longitud:
            combinaciones_totales.append(list(combinacion))
            return
        
        for i in range(numero_inicial, numero_final + 1):#Si quieres que sea exactamente igual que el ejercicio de funciones generadoras el bucle debe ser: for i in range(numero_inicial, numero_final), es decir, quitar el + 1 de numero_final
            
            combinacion.append(i)
            dfs(combinacion)
            combinacion.pop()
            
        return
            
    dfs([])
    return combinaciones_totales
    
if "__main__" == __name__:
    
    resultado = combinaciones_numero(0, 2, 4)#Numero inicial, Numero final - 1, Longitud
    print(resultado)

#(OPCIONAL) Mismo ejercicio que arriba pero con yield(menos memoria)

def combinaciones_numero(numero_inicial, numero_final, longitud):#5
    
    def dfs(combinacion):#[]
        
        if len(combinacion) == longitud:
            yield list(combinacion) #[[0, 0, 0, 0], [0, 0, 0, 1] ..... [4, 4, 4, 3], [4, 4, 4, 4]]
            return
        
        for i in range(numero_inicial, numero_final + 1):#Si quieres que sea exactamente igual que el ejercicio de funciones generadoras el bucle debe ser: for i in range(numero_inicial, numero_final), es decir, quitar el + 1 de numero_final
            
            combinacion.append(i)
            yield from dfs(combinacion)
            combinacion.pop()
            
        return
            
    yield from dfs([])
    
if "__main__" == __name__:
    
    resultado = combinaciones_numero(0, 2, 4)#Numero inicial, Numero final - 1, Longitud
    for combinacion in resultado:
        print(combinacion)

#Ejercicio de iterador con dominios concretos, que calcula todas combinaciones de numeros especificos, con un iterador propio

def permutaciones_numero(lista, longitud):#3
    
    def dfs(permutacion, contador):#[]
        
        if len(permutacion) == longitud:
            yield list(permutacion)
            return
        
        for element in lista[contador]:#6, 1
            
            permutacion.append(element)
            yield from dfs(permutacion, contador + 1)
            permutacion.pop()
            
        return
            
    yield from dfs([], 0)
    
if "__main__" == __name__:
    
    resultado = permutaciones_numero([[6, 2], [7, 3, 1], [9, 2]], 3)#Numero inicial, Numero final - 1, Longitud
    for combinacion in resultado:
        print(combinacion)

#Ejercicio de funciones generadoras como está en el Moddle de una manera más dácil de entender

def next_number(digits, base):
    """
    Suma 1 en un número representado como lista en base 'base'.
    Devuelve la siguiente combinación o None si ya no hay más.
    """
    digits = digits[:]  # copiar para no modificar original
    
    i = len(digits) - 1  # empezamos por el último dígito
    while i >= 0:
        if digits[i] + 1 < base:
            digits[i] += 1
            return digits
        else:
            digits[i] = 0
            i -= 1

    return None  # hemos llegado a [base-1, base-1, ..., base-1]

class My_Iterator:

    def __init__(self, num_digits, base):
        self.num_digits = num_digits
        self.base = base
        self.current = [0] * num_digits  # empezamos en la combinación más baja
        self.finished = False

    def next(self):
        """
        Generador que va devolviendo todas las combinaciones.
        """
        if self.finished:
            return  # No genera nada más

        # Primera combinación: [0,0,0,...]
        yield self.current

        # Generar el resto
        while True:
            nxt = next_number(self.current, self.base)
            if nxt is None:       # No quedan más combinaciones
                self.finished = True
                return
            self.current = nxt
            yield nxt

combinaciones = My_Iterator(4, 2)
for combinacion in combinaciones.next():
    print(combinacion)

#Kruskal hecho con divide y vencerás a mi manera(MUCHO MÁS ENTENDIBLE)

import networkx as nx

def build_graph(input_list):
    
    nodos_vistos = set()
    grafo = nx.Graph()
    
    for element in input_list:
        u, v, w = element
        if u not in nodos_vistos:
            nodos_vistos.add(u)
        elif v not in nodos_vistos:
            nodos_vistos.add(v)
        grafo.add_edge(u, v, weight=w)
    
    for nodo in nodos_vistos:
        grafo.add_node(nodo)
    
    return grafo

def check_cycle(nodo_actual, padre, graphix, visitados=None):
        if visitados is None:
            visitados = set()
        visitados.add(nodo_actual)

        for vecino in graphix.neighbors(nodo_actual):
            if vecino == padre:
                continue

            if vecino in visitados:
                return True

            if check_cycle(vecino, nodo_actual, graphix, visitados):
                return True

        return False

def solve(input_list):
    
    grafo_kruskal = nx.Graph()
    
    def dividir_array(array, left, right):
        
        if left == right:
            peso_total = 0
            u, v, w = array[left]
            
            grafo_kruskal.add_node(u)
            grafo_kruskal.add_node(v)
            grafo_kruskal.add_edge(u, v)
            if not check_cycle(u, None, grafo_kruskal, set()):
                peso_total += w
                return [(u, v, w)], peso_total
            
            grafo_kruskal.remove_edge(u, v)
            return [], 0
                
        medio = (left + right) // 2
        
        elemento_izq, peso_izq = dividir_array(array, left, medio)#["A", "B", 2], 2
        elemento_der, peso_der = dividir_array(array, medio + 1, right)#["A", "D", 8], 8
        
        return elemento_izq + elemento_der, peso_izq + peso_der
    
    kruskilx = dividir_array(input_list, 0, len(input_list) - 1)
    
    return kruskilx
 

if "__main__" == __name__:
    
    grafo = build_graph([("A", "B", 2), ("A", "D", 8), ("A", "E", 14), ("D", "E", 21), ("B", "E", 25), ("B", "C", 19), ("E", "C", 17), ("E", "F", 13), ("F", "C", 5), ("C", "G", 9), ("F", "G", 1)])
    input_list = [("A", "B", 2), ("A", "D", 8), ("A", "E", 14), ("D", "E", 21), ("B", "E", 25), ("B", "C", 19), ("E", "C", 17), ("E", "F", 13), ("F", "C", 5), ("C", "G", 9), ("F", "G", 1)]
    input_list.sort(key=lambda x: x[2])#Ordena por el peso de las tuplas
    resultado = solve(input_list)
    
    print(resultado)

#(OPCIONAL) Ejercicio de las N-Reinas hecho con Branch and Bound(Jodido)

class Node:
    def __init__(self, columna, taken):
        self.columna = columna
        self.taken = taken
    
    def diagonal(self, fila_nueva):
        col_nueva = self.columna + 1

        for col_antes, fila_antes in enumerate(self.taken, start=1):
            if abs(fila_nueva - fila_antes) == abs(col_nueva - col_antes):
                return True

        return False

def solve_branch_and_bound_DFS(num_queens):
    
    alive = []
    soluciones_totales = []

    nodo_raiz = Node(0, [])
    alive.append(nodo_raiz)

    while alive:

        current = alive.pop()

        if current.columna == num_queens:
            soluciones_totales.append(current.taken)
            continue

        for fila in reversed(range(1, num_queens + 1)):
            
            fila0 = fila - 1

            if fila0 in current.taken:
                continue

            if current.diagonal(fila0):
                continue

            nuevo_taken = current.taken + [fila0]

            hijo = Node(current.columna + 1, nuevo_taken)
            alive.append(hijo)
    
    return soluciones_totales


if "__main__" == __name__:
    
    resultado = solve_branch_and_bound_DFS(4)

    print(resultado)

#Ejercicio de implementar el algoritmo de quicksort

def quicksort(array):
    
    def pivote_y_partir(array):
        
        elementos_menores= []
        elementos_mayores = []
        elementos_iguales = []
        pivote = array[-1]
        
        #Hacemos un bucle hasta el penúltimo elemento del array ya que el último es el pivote
        for i in range(0, len(array) - 1):
            
            if array[i] < pivote:
                elementos_menores.append(array[i])
            elif array[i] > pivote:
                elementos_mayores.append(array[i])
            else:
                elementos_iguales.append(array[i])
                
        return elementos_menores, elementos_iguales, pivote, elementos_mayores
    
    def divide_y_venceras(array):
        
        #Hay veces que van a haber subarrays vacíos ya que no hay o elementos mayores que el pivote o elementos menores que el pivote
        if len(array) <= 1:
            return array
        
        menores, iguales, pivote, mayores = pivote_y_partir(array)
        
        menores_ordenados = divide_y_venceras(menores)#[]
        mayores_ordenados = divide_y_venceras(mayores)#[2, 5, 7]
    
        #Convertimos al pivote en una lista ya que estamos haciendo operaciones de listas
        return menores_ordenados + iguales + [pivote] + mayores_ordenados
    
    return divide_y_venceras(array)#[1, 2, 5, 7]
    
    
if "__main__" == __name__:
    
    array = [7, 3, 1, 8, 4, 2, 9]
    resultado = quicksort(array)
    
    print(resultado)

#Ejercicio de implementar el algorimo de huffman

import networkx as nx

def huffman(letras, frecuencias_nodos):
    
    grafo_huffman = nx.Graph()
    letras_sin_poner = letras.copy()

    while len(letras_sin_poner) > 1:

        nodo1 = letras_sin_poner[0]
        nodo2 = letras_sin_poner[1]

        # Como ambos están en frecuencias_nodos, tomamos sus frecuencias directamente
        frecuencia1 = frecuencias_nodos[nodo1]
        frecuencia2 = frecuencias_nodos[nodo2]
        
        nodo_unido = frecuencia1 + frecuencia2

        frecuencias_nodos[nodo_unido] = nodo_unido

        # Añadimos nodos y aristas al grafo
        grafo_huffman.add_node(nodo_unido)
        grafo_huffman.add_node(nodo1)
        grafo_huffman.add_node(nodo2)

        grafo_huffman.add_edge(nodo_unido, nodo1)
        grafo_huffman.add_edge(nodo_unido, nodo2)

        # Eliminar los 2 nodos usados (siempre borrar el mayor índice primero)
        del letras_sin_poner[1]
        del letras_sin_poner[0]

        #Añadimos la frecuencia del nodo nuevo y luego ordenamos la lista con esa frecuencia nueva
        letras_sin_poner.append(nodo_unido)
        letras_sin_poner.sort(key=lambda x: frecuencias_nodos[x])

    return grafo_huffman


if "__main__" == __name__:
    
    nodos_y_frecuencias = {'a': 12, 'b': 2, 'c': 7, 'd': 13, 'e': 14, 'f': 85}

    # Ordenamos para pasarlo como lista
    nodos_ordenados = dict(sorted(nodos_y_frecuencias.items(), key=lambda x: x[1]))
    resultado = huffman(list(nodos_ordenados.keys()), nodos_y_frecuencias)
    
    print(resultado.edges())

#Problema del ladron en donde solos e puede robar casas pares y si robas una casa par no puedes robar la siguiente par

def ladron_con_tabulation(casas):
    
    #Hay también que entender, que todos los problema de tabulation no constan de dos variables
    
    def tabulation(casas):
        
        n = len(casas)
        
        tabla_hecha = (n + 1)*[0]
        
        #Caso base, se puede hacer también así
        #tabla_hecha[1] = tabla_hecha[0]+ casas[0]
        
        for i in range(2, 4):
            if i % 2 == 0:
                tabla_hecha[i] = max(tabla_hecha[i - 2] + casas[i - 1], tabla_hecha[i - 1])
            else:
                tabla_hecha[i] = tabla_hecha[i - 1]
        
        for i in range(5, n + 1):#3
            if i % 2 == 0:
                tabla_hecha[i] = max(tabla_hecha[i - 4] + casas[i - 3], tabla_hecha[i - 1])
            else:
                tabla_hecha[i] = tabla_hecha[i - 1]
        
        #Este bucle se asegure de que no reobes dos casa consecutivas ya que si coges la opcion de tabla_hecha[i - 2] + casas[i - 1], signiifca que robastes dos casas antes, y si coges la otra opcion tabla_hecha[i - 1] significa que robastes la anterior casa
        
        casas_robadas = []
        i = n

        while i > 0:
            # Si no robaste la casa i
            if tabla_hecha[i] == tabla_hecha[i - 1]:
                i -= 1
            else:
                # Si robaste la casa i
                casas_robadas.append(i - 1)   # guardamos el índice real de la casa
                i -= 4

        casas_robadas.reverse()
        
        return tabla_hecha[n], casas_robadas
    
    return tabulation(casas)


if __name__ == "__main__":
    
    casas = [3, 10, 3, 1, 2, 8, 4, 7, 2, 9, 11, 5]
    resultado = ladron_con_tabulation(casas)
    
    print(resultado)

#Algoritmo de Dijkstra a mi manera con greedy

import networkx as nx
import heapq # Necesario para la cola de prioridad

def build_graph(input_list):
    
    nodos_vistos = set()
    grafo = nx.Graph()
    
    for element in input_list:
        u, v, w = element
        if u not in nodos_vistos:
            nodos_vistos.add(u)
        elif v not in nodos_vistos:
            nodos_vistos.add(v)
        grafo.add_edge(u, v, weight=w)
    
    for nodo in nodos_vistos:
        grafo.add_node(nodo)
    
    return grafo

def dijkstra_real(grafo, origen, destino):
    # Diccionario de distancias infinitas al principio
    distancias = {nodo: float('inf') for nodo in grafo.nodes()}
    distancias[origen] = 0
    
    # Cola de prioridad: (distancia_acumulada, nodo_actual, camino_recorrido)
    prioridad = [(0, origen, [origen])]
    
    while prioridad:
        (dist_acumulada, nodo_actual, camino) = heapq.heappop(prioridad)

        if nodo_actual == destino:
            return camino, dist_acumulada

        if dist_acumulada > distancias[nodo_actual]:
            continue

        for vecino in grafo.neighbors(nodo_actual):
            peso = grafo[nodo_actual][vecino]['weight']
            nueva_distancia = dist_acumulada + peso
            
            # Si encontramos un camino más corto a este vecino, actualizamos
            if nueva_distancia < distancias[vecino]:
                distancias[vecino] = nueva_distancia
                heapq.heappush(prioridad, (nueva_distancia, vecino, camino + [vecino]))

    return None, float('inf')


if "__main__" == __name__:
    
    grafo = build_graph([("A", "H", 6), ("A", "B", 4), ("H", "B", 5), ("B", "C", 9), ("B", "E", 2), ("E", "D", 15), ("F", "E", 8), ("H", "G", 14), ("H", "F", 10), ("G", "F",3)])
    sendero, coste_total = dijkstra_real(grafo, "A", "F")
    
    print(f"El sendero es {sendero}, con un coste de {coste_total}")

#Algoritmo de Prim con greedy

import networkx as nx
import heapq # Necesario para la cola de prioridad

def build_graph(input_list):
    
    nodos_vistos = set()
    grafo = nx.Graph()
    
    for element in input_list:
        u, v, w = element
        if u not in nodos_vistos:
            nodos_vistos.add(u)
        elif v not in nodos_vistos:
            nodos_vistos.add(v)
        grafo.add_edge(u, v, weight=w)
    
    for nodo in nodos_vistos:
        grafo.add_node(nodo)
    
    return grafo

def prim_mst(grafo, inicio):
    # MST guardará las aristas del Árbol de Expansión Mínima
    mst = []
    nodos_visitados = set([inicio])
    
    # La cola de prioridad guarda: (peso_arista, nodo_u, nodo_v)
    # Metemos todas las aristas que salen del nodo inicial
    aristas_candidatas = []
    for vecino in grafo.neighbors(inicio):
        peso = grafo[inicio][vecino]['weight']
        heapq.heappush(aristas_candidatas, (peso, inicio, vecino))
    
    coste_total = 0
    
    while aristas_candidatas:
        # Extraemos la arista más barata de TODO el borde de lo que ya hemos conectado
        peso, u, v = heapq.heappop(aristas_candidatas)
        
        if v not in nodos_visitados:
            # Si el nodo destino no está en el MST, lo añadimos
            nodos_visitados.add(v)
            mst.append((u, v, peso))
            coste_total += peso
            
            # Ahora añadimos a la cola las aristas que salen del nuevo nodo v
            for vecino_de_v in grafo.neighbors(v):
                if vecino_de_v not in nodos_visitados:
                    nuevo_peso = grafo[v][vecino_de_v]['weight']
                    heapq.heappush(aristas_candidatas, (nuevo_peso, v, vecino_de_v))
                    
    return mst, coste_total


if "__main__" == __name__:
    
    grafo = build_graph([("A", "H", 6), ("A", "B", 4), ("H", "B", 5), ("B", "C", 9), ("B", "E", 2), ("E", "D", 15), ("F", "E", 8), ("H", "G", 14), ("H", "F", 10), ("G", "F",3)])
    sendero, coste_total = prim_mst(grafo, "A")
    
    print(f"El sendero es {sendero}, con un coste de {coste_total}")

#Ejercicio parcial de mochila con poda de iterador(FUMADON)

#Se pone de esta manera el iterador porque te pide un orden concreto de las distintas combinacones(ayudado por chatgix)

class SubsetIterator:
    def __init__(self, costs, budget):
        self.costs = costs # Se asume que costs ya es la lista de strings "NAME COST"
        self.budget = budget
        self.n = len(costs)

    def next(self):
        def backtrix(indice, tiempo_actual, solucion_actual):
            # Caso base: hemos decidido sobre todos los proyectos (0 hasta n-1)
            if indice == self.n:
                yield (list(solucion_actual), tiempo_actual)
                return
                
            # Extraemos datos del proyecto actual
            proyecto, coste_str = self.costs[indice].split(" ")
            coste = int(coste_str)
            
            # RAMA 1: NO INCLUIR (Siempre se explora)
            #Esto hace lo mismo que el yield from
            for res in backtrix(indice + 1, tiempo_actual, solucion_actual):
                yield res
                
            # RAMA 2: INCLUIR (Solo si cabe en el presupuesto)
            if tiempo_actual + coste <= self.budget:
                solucion_actual.append(proyecto)
                #Esto hace lo mismo que el yield from
                for res in backtrix(indice + 1, tiempo_actual + coste, solucion_actual):
                    yield res
                solucion_actual.pop() # Backtracking
                
        # Iniciamos: índice 0, tiempo 0, lista vacía
        return backtrix(0, 0, [])

def desempate_lexicografico(mejores_combinaciones):

    indices = [[int(element[1:]) for element in combinacion] for combinacion in mejores_combinaciones]
    
    mejor_indice_lista = min(indices)
    
    posicion = indices.index(mejor_indice_lista)
    
    return mejores_combinaciones[posicion]

def solve_knapsack(costes, budget):
    
    costes_totales = costes[1:]
    combinaciones = SubsetIterator(costes_totales, budget)
    mejor_tiempo = 0
    mejor_combinacion = []
    for combinacion in combinaciones.next():
        proyectos, tiempo = combinacion
        if tiempo > mejor_tiempo:
            mejor_tiempo = tiempo
            mejor_combinacion = [proyectos]
        elif tiempo == mejor_tiempo:
            mejor_combinacion.append(proyectos)

    if len(mejor_combinacion) > 1:
        mejor_combinacion = desempate_lexicografico(mejor_combinacion)
        
        return mejor_combinacion
    
    return mejor_combinacion

if "__main__" == __name__:
    
    input_list = [("5 100"), ("P1 20"), ("P2 50"), ("P3 30"), ("P4 40"), ("P5 70")]
    resultado = solve_knapsack(input_list, 100)
    
    print(resultado)

#(UTIL)Funcion que te devuelve todas las combinaciones(sin repeticiones) de una manera específica, como te las printea el iterador del ejercicio de arriba

def solve(n):
  
  conbinaciones = []
  combinacion = []#[0, 1]
  
  def dfs(i):#i=1
    
    if i == n:
      conbinaciones.append(list(combinacion))
      return
  
    dfs(i + 1)
    
    combinacion.append(i)
    dfs(i + 1)
    combinacion.pop()
    
    return

  dfs(0)
  
  return conbinaciones

print(solve(3))

#(OPCIONAL) Forma que hizo chatgix para probar con monedas repetidas y no repetidas

def solve(coins, change):
    todas_soluciones = []

    def dfs(coste_actual, solucion_actual, start):
        if coste_actual == change:
            todas_soluciones.append(list(solucion_actual))
            return

        if coste_actual > change:
            return

        for i in range(start, len(coins)):
            # Elegimos la moneda
            solucion_actual.append(coins[i])

            # 🔹 CASO 1: permitir repetir la misma moneda
            dfs(coste_actual + coins[i], solucion_actual, i)

            # 🔹 CASO 2: no repetir moneda (avanzamos índice)
            dfs(coste_actual + coins[i], solucion_actual, i + 1)

            solucion_actual.pop()

    dfs(0, [], 0)
    return todas_soluciones


if __name__ == "__main__":
    input_list = [5, 2, 1, 10, 10, 2]
    resultado = solve(input_list, 12)
    print(resultado)

#(OPCIONAL) Printear todas las formas con un dfs y printear cada elemento de la lista si en la combinacion esta a 1

class My_Iterator:

    def __init__(self, num, base):
        # 2.1 Añade código aqui
        # ...
        self.num = num
        self.base = base

    def next(self):
        # 2.2 Añade código aqui
        # ...
        def dfs(valor, combinacion_actual):
            
            if len(combinacion_actual) == self.num:
                lista_objetos = ["Manzana", "Pera", "Naranja"]
                yield [lista_objetos[i] for i in range(0, self.base + 1) if combinacion_actual[i] == 1]
                return
            
            for i in range(self.base):
                
                combinacion_actual.append(i)
                for res in dfs(valor, combinacion_actual):
                    yield res
                combinacion_actual.pop()
            
            return
            
        return dfs(0, [])

numeros = My_Iterator(3, 2).next()
for numero in numeros:
    print(numero)

#(OPCIONAL) Otra forma de mostrar las combianciones de forma canonica

class My_Iterator:

    def __init__(self, num, base):
        # 2.1 Añade código aqui
        # ...
        self.num = num
        self.base = base

    def next(self):
        # 2.2 Añade código aqui
        # ...
        def dfs(valor, combinacion_actual):
            
            yield list(combinacion_actual)
            
            for i in range(valor, self.base):
                
                combinacion_actual.append(i)
                yield from dfs(i + 1, combinacion_actual)
                combinacion_actual.pop()
            
            return
            
        return dfs(0, [])

numeros = My_Iterator(3, 3).next()
for numero in numeros:
    print(numero)

#Ejercicio de los LEDS del primer parcial, no es dificil pero tampoco facil

import networkx as nx

def build_graph(input_list):
    
    nodos_vistos = set()
    grafo = nx.DiGraph()
    
    for element in input_list:
        u, v = element.split(" ")
        if u not in nodos_vistos:
            nodos_vistos.add(u)
        elif v not in nodos_vistos:
            nodos_vistos.add(v)
        grafo.add_edge(u, v)
    
    for nodo in nodos_vistos:
        grafo.add_node(nodo)
    
    return grafo

def find_lit_leds(grafo):
    
    cola = Queue()#[]
    caminos_leds = []#[[Vcc], [Vcc, SW1], [Vcc, SW2], [Vcc, SW1, LED1], [Vcc, SW1, LED1, GND], [LED2], [LED2, GND]]
    nodos_vistos = set()
    
    for node in grafo.nodes():
        
        #Se pone esta condición para no mirar varias veces un camino ya visto anteriormente
        if node in nodos_vistos:
            continue
        
        cola.enqueue(node)
        
        #Esto se pone para que la condicion de más abajo de los caminos pueda efectuarse y no hacer una contradiccion
        #Y se mete el node como [node] porque sino se veria letra por letra y seria un fallo
        caminos_leds.append([node])
        
        while cola.isEmpty() != True:
            
            nodo_actual = cola.dequeue()#GND
            
            #Esta condicion es para evitar caminos duplicados como la de arriba
            if nodo_actual in nodos_vistos:
                continue
            
            #Añadimos los nodos procesados al conjunto de nodos vistos para que las condiciones funcionen
            nodos_vistos.add(nodo_actual)
            
            #Miramos los caminos vistos hasta ahora y el camino que termine por el nodo actual es el que miramos para continuar construyendo caminos
            for camino in caminos_leds:
                
                if camino[-1] == nodo_actual:
            
                    #Miramos los sucesores para seguir explorando el camino
                    for succ in grafo.successors(nodo_actual):
                        
                        cola.enqueue(succ)
                        #Metemos el succ como [succ] ya que camino es una lista y hacer una suma de lista para meter el camino completo como una lista
                        caminos_leds.append(camino + [succ])
    
    leds_activos = []
    
    for camino in caminos_leds:
        
        #Si empieza por Vcc y termina por GND es un camino valido
        if camino[0] == "Vcc" and camino[-1] == "GND":
            
            #Miramos los elementos y si el elemento tiene la substring LED entonces es un led valido
            for element in camino:
                
                if "LED" in element:
                    
                    leds_activos.append(element)
    
    #Si hay dos caminos que encienden ambos un led, esto sirve para evitar duplicados
    return sorted(set(leds_activos))


if "__main__" == __name__:
    
    input_list = [("Vcc SW1"), ("SW1 LED1"), ("LED1 GND"), ("Vcc SW2"), ("LED2 GND")]
    grafo = build_graph(input_list)
    leds_ordenados = find_lit_leds(grafo)
    
    print(leds_ordenados)

#(OPCIONAL) Ejercicio de N-Queens con Branch and Bound SIN PODA(Más entendible)

def solve_branch_and_bound_DFS(num_queens):
    """"
    :param capacity: capacidad de la mochila
    :param items: items de la mochila
    :param record_visiting_order: activa/desactiva el registro de nodos visitados
    :return: Por ahora sólo devuelve la lista de nodos visitados
    """

    # Completa este código para realizar el recorrido DFS; tienes
    # indicados los sitios que debes completar con tres puntos
    # suspensivos ("...")

    # Utilizamos la lista 'alive' como nuestra pila de nodos vivos
    # (pendientes de visitar) para programar nuestro recorrido DFS.

    alive = Stack()
    
    # Utilizamos la lista Visiting_Order como el registro de nodos
    # visitados (el contenido final de esta lista lo utiliza el VPL
    # para comprobar que nuestro recorrido DFS es correcto).

    visiting_order = []

    # 1) Creamos el nodo raiz (en este VPL todavía no utilizamos los
    #    parámetros taken, value, room, con lo que se inicializan con
    #    lista vacía y 0). El único valor necesario en el nodo es el
    #    indice al primer elemento de la lista (index = 0).
    # ...
    
    nodo_raiz = Node(0, [])
    
    alive.push(nodo_raiz)

    # Lo añadimos a la lista de nodos vivos (alive)
    # ...

    # Mientras haya nodos en la lista de nodos vivos
    # ...
    while alive.isEmpty() != True:  #sustituir el True por la condición que considere más adecuada
        
        # Avanzamos al siguiente nodo de nuestro recorrido DFS (hacemos un pop
        # de la lista) y lo registramos en nuestro recorrido DFS.

        current_node = alive.pop()
        
        visiting_order.append(current_node.index)
        
        if current_node.index < num_queens:
        
            for fila in range(1, num_queens + 1):#[]
                
                lista_opcion = current_node.rows.copy()
                lista_opcion.append(fila)
                nodo_opcion = Node(current_node.index + 1, lista_opcion)
                alive.push(nodo_opcion)

    #Si por cada nivel hay 4 nodos sería:
    #1 + 4^1 + 4^2 + 4^3 + 4^4 = 341
    return visiting_order

#(OPCIONAL) Problema de las N-Queens con Branch and Bound CON PODA(el método de la diagonal se puede hacer más óptimo)

from collections import namedtuple

Item = namedtuple("Item", ['index', 'value', 'weight'])

class Node:
    def __init__(self, index, rows):
        self.index = index
        self.rows = rows
        return
    
    #Método de diagonal, poco óptimo pero funciona, VIVA FRANCO
    def diagonal(self, rows):
        for i in range(len(rows)):
            for j in range(len(rows)):
                if i == j:
                    continue
                
                valor1 = abs(rows.index(rows[i]) - rows.index(rows[j]))
                valor2 = abs(rows[i] - rows[j])
                
                if valor1 == valor2:
                    return True
            
        return False

class Stack:
   def __init__(self):
       self.items = []

   def isEmpty(self):
       return self.items == []

   def push(self, item):
       self.items.append(item)

   def pop(self):
       return self.items.pop()

   def peek(self):
       return self.items[len(self.items)-1]

   def size(self):
       return len(self.items)

def solve_branch_and_bound_DFS(num_queens):
    """"
    :param capacity: capacidad de la mochila
    :param items: items de la mochila
    :param record_visiting_order: activa/desactiva el registro de nodos visitados
    :return: Por ahora sólo devuelve la lista de nodos visitados
    """

    # Completa este código para realizar el recorrido DFS; tienes
    # indicados los sitios que debes completar con tres puntos
    # suspensivos ("...")

    # Utilizamos la lista 'alive' como nuestra pila de nodos vivos
    # (pendientes de visitar) para programar nuestro recorrido DFS.

    alive = Stack()
    
    # Utilizamos la lista Visiting_Order como el registro de nodos
    # visitados (el contenido final de esta lista lo utiliza el VPL
    # para comprobar que nuestro recorrido DFS es correcto).

    visiting_order = []

    # 1) Creamos el nodo raiz (en este VPL todavía no utilizamos los
    #    parámetros taken, value, room, con lo que se inicializan con
    #    lista vacía y 0). El único valor necesario en el nodo es el
    #    indice al primer elemento de la lista (index = 0).
    # ...
    combinaciones_validas = []
    
    nodo_raiz = Node(0, [])
    
    alive.push(nodo_raiz)

    # Lo añadimos a la lista de nodos vivos (alive)
    # ...

    # Mientras haya nodos en la lista de nodos vivos
    # ...
    while alive.isEmpty() != True:  #sustituir el True por la condición que considere más adecuada
        
        # Avanzamos al siguiente nodo de nuestro recorrido DFS (hacemos un pop
        # de la lista) y lo registramos en nuestro recorrido DFS.

        current_node = alive.pop()
        
        #Si la longitud de alguna combinacion llega a ser igual que el valor de num_queens significa que es válida
        if len(current_node.rows) == num_queens:
            combinaciones_validas.append(current_node.rows)
        
        visiting_order.append(current_node.index)
        
        if current_node.index < num_queens:
        
            #Hacemos N hijos a cada nodo donde N es el valor de num_queens
            for fila in range(1, num_queens + 1):#[]
                
                lista_opcion = current_node.rows.copy()
                #Para que no hayan dos reinas en la misma fila
                if fila not in lista_opcion:
                    lista_opcion.append(fila)
                    nodo_opcion = Node(current_node.index + 1, lista_opcion)
                    #Y de paso se mira la diagonal si la cumple la combinacion
                    if not nodo_opcion.diagonal(lista_opcion):
                        alive.push(nodo_opcion)

    #Si por cada nivel hay 4 nodos sería:
    #1 + 4^1 + 4^2 + 4^3 + 4^4 = 341(ESTO ES SIN PODA, CON PODA SE QUEDA CON 2)
    return combinaciones_validas


if "__main__" == __name__:
    
    num_queens = 4
    resultado = solve_branch_and_bound_DFS(num_queens)
    
    print(f"Las soluciones validas para {num_queens} reinas son: {resultado}")

#(OPCIONAL) El algoritmo de quicksort pero con un pequeño cambio

def quicksort(items):
    
    def dividir_y_partir(array):
        
        pivote = array[-1]
        menores = []
        mayores = []
        iguales = [pivote] #<--- Este es el cambio, y por esto no se devuelve el pivote sino solo iguales, porque el pivote ya está en iguales y el elif ahora sí funciona
        
        for i in range(len(array) - 1):
            
            if array[i] > pivote:
                mayores.append(array[i])
            elif array[i] < pivote:
                menores.append(array[i])
            elif array[i] == pivote:
                iguales.append(array[i])
        
        return menores, iguales, mayores

    def divide_y_venceras(items):
        
        if len(items) <= 1:
            return items
        
        menores, iguales, mayores = dividir_y_partir(items)
        izquierda = divide_y_venceras(menores)
        derecha = divide_y_venceras(mayores)
        
        return izquierda + iguales + derecha
    
    return divide_y_venceras(items)


if "__main__" == __name__:
    
    resultado = quicksort([3, 1, 7, 3, 6, 2, 5, 4, 9, 0])
    
    print(resultado)

#Problema de tirada de dados, es más fácil que el de la mochila

class RollsIterator:
    
    """
    Iterador que expone un método generador `next()`
    que produce las tiradas válidas como strings
    con valores separados por espacios.

    Requisitos:
    - Implementa backtracking con poda determinista.
    - Genera en orden lexicográfico (caras en orden 1..s).
    - No construyas toda la lista en memoria; 
      usa `yield` para producir resultados.
    """

    def __init__(self, d: int, s: int, T: int):
        self.d = d
        self.s = s
        self.T = T
    
    # Ejemplo:
    # Parámetros: d = 2, s = 3, T = 4
    # Tiradas válidas (en orden):
    # 1 1
    # 1 2
    # 1 3
    # 2 1
    # 2 2
    # 3 1
    def next(self):
        
        def dfs(combinacion_actual, suma_actual):
            
            #Si la suma supera entonces returneamos y seguimos con otra combinacion
            if suma_actual > self.T:
                return
            
            #Si es igual generamos la combinación
            if len(list(combinacion_actual)) == self.d:
                #Mi forma
                #string_salida = ""
                #for element in combinacion_actual:
                #    string_salida += f"{element} "
                #yield string_salida.strip()
                
                #Forma chatgix
                yield " ".join(map(str, combinacion_actual))
                return
            
            #Hacemos el bucle para poder guardar el número de tiradas de los diferentes dados
            for i in range(1, self.s + 1):#1
                
                combinacion_actual.append(i)
                for dado in dfs(combinacion_actual, suma_actual + i):
                    yield dado
                combinacion_actual.pop()
            
            return
        
        return dfs([], 0)

#Ejecutamos el iterador y generamos las distintas combianciones
combinaciones = RollsIterator(2, 6, 7).next()
for combinacion in combinaciones:
    print(combinacion)

#Ejercicio de hacer devolver un orden topológico válido o ciclo si tiene ciclo el grafo

import networkx as nx

def build_graph(input_list):
    grafo = nx.DiGraph()
    for element in input_list:
        # Esto añade los nodos y la arista de un solo golpe
        u, v = element.split(" ")
        grafo.add_edge(u, v)
    return grafo

def tiene_ciclo(grafo, actual, objetivo, visitados=None):
    if visitados is None:
        visitados = set()

    for pred in grafo.predecessors(actual):
        if pred == objetivo:
            return True
        if pred not in visitados:
            visitados.add(pred)
            if tiene_ciclo(grafo, pred, objetivo, visitados):
                return True
    return False

def topo_sort_dfs(grafo):
    
    lista_final = []#[IN1, IN2, AND1, IN3, OR1, NOT1, OUT]
    nodos_vistos = set()#{IN1, IN2, AND1, IN3, OR1, NOT1, OUT}
    predecesores_encontrados = []
    pila = []#[]
    
    #Hacemos un bucle ya que no nos dan un primer nodo para comenzar a procesar
    for node in grafo.nodes():
        
        #Si el nodo ya está visto lo ignoramos
        if node in nodos_vistos:
            continue    
            
        pila.append(node)
        
        while len(pila) != 0:
            
            nodo_actual = pila.pop()#OR1
            
            #Comprobamos empezando por el nodo actual si existe algun ciclo en el grafo, y si existe returneamos que si existe
            if tiene_ciclo(grafo, nodo_actual, nodo_actual):
                return [], False
            
            #Creamos una variable para contar los predecesores que tiene el nodo actual
            pred = 0
            
            #Hacemos un bucle para ver los predecesores que tiene el nodo actual
            for predeccesors in grafo.predecessors(nodo_actual):#
                
                #Si el predecesor no lo hemos visto pues lo añadimos a la pila y le sumamos uno al contador
                if predeccesors not in nodos_vistos:
                    pila.append(predeccesors)
                    pred += 1
            
            #Si hay algun nodo que no tiene predecesores significa que lo podemos añadir a la lista ya que no hay nodos que procesar antes que este
            if pred == 0:
                lista_final.append(nodo_actual)
                nodos_vistos.add(nodo_actual)
            #Y si es diferente que 0, entonces metemos el nodo actual al principio de la pila para procesarlo de nuevo después de procesar a sus predecesores
            else:
                pila.insert(0, nodo_actual)
        
    return lista_final, True


if "__main__" == __name__:
    
    input_list = [("IN1 G1"), ("G1 G2"), ("G2 out")]
    grafo = build_graph(input_list)
    resultado = topo_sort_dfs(grafo)
    
    print(resultado)

#Ejercicio para ver componentes conectados y desconectados de la corriente

import networkx as nx

def build_graph(input_list):
    
    nodos_vistos = set()
    grafo = nx.DiGraph()
    
    for element in input_list:
        u, v = element.split(" ")
        grafo.add_edge(u, v)
    
    return grafo

def check_circuit_connectivity(grafo):
    
    cola = Queue()#[]
    caminos_leds = []#[[Vcc], [Vcc, SW1], [Vcc, SW2], [Vcc, SW1, LED1], [Vcc, SW1, LED1, GND], [LED2], [LED2, GND]]
    nodos_vistos = set()
    
    for node in grafo.nodes():
        
        #Se pone esta condición para no mirar varias veces un camino ya visto anteriormente
        if node in nodos_vistos:
            continue
        
        cola.enqueue(node)
        
        #Esto se pone para que la condicion de más abajo de los caminos pueda efectuarse y no hacer una contradiccion
        #Y se mete el node como [node] porque sino se veria letra por letra y seria un fallo
        caminos_leds.append([node])
        
        while cola.isEmpty() != True:
            
            nodo_actual = cola.dequeue()#GND
            
            #Esta condicion es para evitar caminos duplicados como la de arriba
            if nodo_actual in nodos_vistos:
                continue
            
            #Añadimos los nodos procesados al conjunto de nodos vistos para que las condiciones funcionen
            nodos_vistos.add(nodo_actual)
            
            #Miramos los caminos vistos hasta ahora y el camino que termine por el nodo actual es el que miramos para continuar construyendo caminos
            for camino in caminos_leds:
                
                if camino[-1] == nodo_actual:
            
                    #Miramos los sucesores para seguir explorando el camino
                    for succ in grafo.successors(nodo_actual):
                        
                        cola.enqueue(succ)
                        #Metemos el succ como [succ] ya que camino es una lista y hacer una suma de lista para meter el camino completo como una lista
                        caminos_leds.append(camino + [succ])
    
    #Calculamos todos los componentes y ponemos sets para evitar duplicados
    todos_los_componentes = {node for node in grafo.nodes() if "Vcc" not in node and "GND" not in node and "SW" not in node}
    componentes_conectados = set()
    componentes_desconectados = set()
    
    for camino in caminos_leds:
        
        #Si empieza por Vcc y termina por GND es un camino valido
        if camino[0] == "Vcc" and camino[-1] == "GND":
            
            #Miramos los elementos, quitando el primero y ultimo ignorando los switches
            for element in camino[1:len(camino) - 1]:
                
                if "SW" not in element:
                    
                    componentes_conectados.add(element)
    
    #Los componentes desconectados es el resto de la resta entre el total de componentes y los componentes conectados
    #Esta operación del - solo se puede hacer con conjuntos, en listas te salta un error
    componentes_desconectados = todos_los_componentes - componentes_conectados
    
    return sorted(componentes_conectados), sorted(componentes_desconectados)


if "__main__" == __name__:
    
    input_list = [("Vcc LED1"), ("LED1 GND"), ("Vcc GND")]
    grafo = build_graph(input_list)
    leds_ordenados = check_circuit_connectivity(grafo)
    
    print(leds_ordenados)

#(OPCIONAL) Ejercicio de encontrar la mejor combinación cortando una barilla devolviendo el mejor precio y la combinacion cogida

def corte_barilla(n):
    
    memo = {}
    precios = [1, 5, 8, 9 ,10, 17, 17, 20]
    
    def calculo(n):#0
        
        if n == 0:
            return (0, [])
        elif n in memo:
            return memo[n]
        
        precio_maximo = -9999
        longitud_maxima = []
        
        for i in range(1, n + 1):
            
            precio_resultado, longitud_agarrada = calculo(n - i)
            #El precios[i - 1] es el precio de la barra que cortas no de la que queda, por ejemplo
            #si tienes 8 y le cortas 2, coges el precio de 2 no de 6
            precio_actual = precios[i - 1] + precio_resultado
            
            if precio_actual > precio_maximo:
                precio_maximo = precio_actual
                longitud_maxima = [i] + longitud_agarrada
        
        memo[n] = (precio_maximo, longitud_maxima)
        
        return memo[n]
    
    return calculo(n) 
    
    
if "__main__" == __name__:
    
    resultado = corte_barilla(8)
    print(resultado)

#(OPCIONAL) Ver combinaciones de monedas que dan N con longitud minima

def monedas(n):
    
    memo = {}
    coins = [1, 2, 4, 3, 5]
    
    def calculo(n):
        
        if n == 0:
            return (0, [[]])
        elif n < 0:
            #Se pone 9999 para cuando comparemos si es menor que la longitud minima de falso y asi nunca lo cogeremos
            return (9999, [])
        elif n in memo:
            return memo[n]
        
        longitud_minima = 9999
        monedas_minimas = []
        
        for moneda in coins:
            
            longitud_cogidas, monedas_cogidas = calculo(n - moneda)
            
            if longitud_cogidas == 9999:
                continue
            
            for combinacion in monedas_cogidas:
                nueva = combinacion + [moneda]
                print(monedas_cogidas)
                print(f"Para n={n}: He cogido {combinacion} de n={n-moneda} y le he sumado la moneda [{moneda}] -> Resulta: {nueva}")
                if longitud_cogidas + 1 < longitud_minima:
                    longitud_minima = longitud_cogidas + 1
                    monedas_minimas = [nueva]
                elif longitud_cogidas + 1 == longitud_minima:
                    monedas_minimas.append(nueva)
        
        memo[n] = (longitud_minima, monedas_minimas)
        
        return memo[n]
    
    return calculo(n) 
    
    
if "__main__" == __name__:
    
    resultado = monedas(6)
    print(resultado)

#Ejercicio del ladron con tabulation(tenía variaciones pero no el original)

def ladron(casas):
    
    n = len(casas)
    
    tabla = [0] * (n + 1)
    
    #Casos base
    tabla[1] = casas[0]
    
    for i in range(2, n + 1):
        #El indice de la casa es así porque tiene uno menos de longitud
        #Lo que se hace es si coges la opcion: tabla[i - 2] + casas[i - 1], significa que robas la casa de hace dos casas tabla[i - 2]
        #Y luego le sumas el valor de la casa actual ya que la puedes robar porque no robastes la primera
        #Pero si coges la otra opcion entonces estarías robando la primera casa, la anterior por eso: tabla[i - 1]
        tabla[i] = max(tabla[i - 2] + casas[i - 1], tabla[i - 1])
    
    i = n
    casas_robadas = []
    
    while i > 0:
        
        if tabla[i] == tabla[i - 1]:
            i -= 1
        else:
            casas_robadas.append(i - 1)
            i -= 2
        
    casas_robadas.reverse()
    return tabla[n], casas_robadas
    
    
if "__main__" == __name__:
    
    casas = [3, 10, 3, 1, 2]
    resultado = ladron(casas)
    
    print(resultado)

#Ejercicio del ladrón pero si robas una casa debes saltarte las 2 siguientes

def ladron(casas):
    
    n = len(casas)
    
    tabla = [0] * (n + 1)
    
    #Casos base
    tabla[1] = casas[0]
    tabla[2] = casas[1]
    
    for i in range(3, n + 1):
        #Si elegimos la primera opción estaríamos robando la casa i - 3, más la casa actual
        #Y si cogemos la otra opción es que la otra casa tiene mayor valor que robando estas dos
        tabla[i] = max(tabla[i - 3] + casas[i - 1], tabla[i - 1])
        
    i = n
    casas_robadas = []
    
    while i > 0:
    
        if tabla[i] != tabla[i - 1]:
            casas_robadas.append(i - 1)
            i -= 3
        else:
            i -= 1
            
    casas_robadas.reverse()
    
    return tabla[n], casas_robadas
    
    
if "__main__" == __name__:
    
    casas = [3, 10, 3, 1, 2]
    resultado = ladron(casas)
    
    print(resultado)

#Ejercicio en donde el ladron si roba una casa par no puede robar la siguiente par

def ladron(casas):
    
    n = len(casas)
    
    tabla = [0] * (n + 1)
    
    #Casos base, sabiendo que cuando el indice de la lista de casas es impar la casa es numero par
    #Por ejemplo en casas[1], el indice es 1 pero la casa es la 2 ya que la priemra casa es la casas[0]
    #Y luego en la tabla[1] se pone 0 ya que la casa no se puede robar, y la casa 3 es como condición de que coge el mismo valor del indicde anterior ya que no lo puede robar
    tabla[1] = 0
    tabla[2] = casas[1]
    
    for i in range(3, n + 1):
        if i % 2 == 0:
            #Se pone como segunda opcion tabla[i - 2], ya que la otra opcion es la anterior casa par
            tabla[i] = max(tabla[i - 4] + casas[i - 1], tabla[i - 2])
        else:
            #Si la casa no se puede robar copiamos el valor anterior
            tabla[i] = tabla[i - 1]
    
    i = n
    casas_robadas = []
    
    while i > 0:
        
        #Si el indice es par y la casa par es diferente a la anterior casa par entonces significa que la robamos
        if i % 2 == 0 and tabla[i] != tabla[i - 2]:
            casas_robadas.append(i - 1)
            i -= 4
        else:
            i -= 1
    
    casas_robadas.reverse()
    
    return tabla[n], casas_robadas
    
    
if "__main__" == __name__:
    
    casas = [3, 10, 3, 1, 2]
    resultado = ladron(casas)
    
    print(resultado)

#Ejercicio de la mochila con tabulation el original

def mochila(pesos, valores, capacidad):
    
    n = len(pesos)
    
    #Creamos la tabla
    tabla = [[0 for _ in range(capacidad + 1)] for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for j in range(1, capacidad + 1):
            if pesos[i - 1] <= j:
                #Cogemos el mayir valor entre la fila anterior y restandole el peso del objeto más el valor del objeto anterior o el valor del objeto anterior
                tabla[i][j] = max(tabla[i - 1][j - pesos[i - 1]] + valores[i - 1], tabla[i - 1][j])
            else:
                tabla[i][j] = tabla[i - 1][j]
                
    i = n
    k = capacidad
    objetos_cogidos = []
    
    while i > 0 and k > 0:
        
        #Si el objeto actuales diferente al anterior es que lo hemos cogido
        if tabla[i][k] != tabla[i - 1][k]:
            objetos_cogidos.append(i - 1)
            k -= pesos[i - 1]
            i -= 1
        else:
            i -= 1
    
    objetos_cogidos.reverse()
    
    return tabla[n][capacidad], objetos_cogidos
    
    
if "__main__" == __name__:
    
    pesos = [2, 4, 2]
    valores = [3, 5, 6]
    capacidad = 4
    resultado = mochila(pesos, valores, capacidad)
    
    print(resultado)

#Ejercicio quicksort pero con tuplas y más restricciones que sus MUERTARAZOS LUIS TUS MUERTAZOS TODOS

def quicksort(hoteles):
    
    def pivote_y_partir(array):#(Barcelo 4 10), (Riu 5 1)

        pivote = array[-1]
        mayores = []
        menores = []
        p_nombre, p_rating, p_reviews = pivote.split(" ")
        p_rating, p_reviews = int(p_rating), int(p_reviews)
        
        for i in range(0, len(array) - 1):
            nombre, rating, reviews = array[i].split(" ")
            rating, reviews = int(rating), int(reviews)
            if rating > p_rating:
                menores.append(array[i])
            elif rating < p_rating:
                mayores.append(array[i])
            else:
                if reviews > p_reviews:
                    menores.append(array[i])
                elif reviews < p_reviews:
                    mayores.append(array[i])
                else:
                    #Podemos hacer una comparacion lexicografica comparando con signos de < o >, python compara caracter por caracter
                    #Como es comparar un nombre con otro pues se usa esto si fuese un array entero usariamos sorted()
                    #Si por ejemplo tienes un palabra con mayusculas puedes hacer palabra.lower() para pasar todos los caracteres a minúsculas, o palabra.upper() que es lo mismo pero al revés
                    #Esto se debe hacer ya que los caracteres se comparan por caracteres ASCII y por ejemplo la letra S es menor que a, así que lo mejor es pasar o toda la palabra a mayúsculas o minúsculas
                    if nombre < p_nombre:
                        menores.append(array[i])
                    else:
                        mayores.append(array[i])
        
        return menores, pivote, mayores

    def divide_y_venceras(array):
        
        if len(array) <= 1:
            return array
        
        menores, pivote, mayores = pivote_y_partir(array)
        
        izq = divide_y_venceras(menores)
        der = divide_y_venceras(mayores)
        
        return izq + [pivote] + der
    
    lista_ordenada = divide_y_venceras(hoteles)
    
    return [tupla.split(" ")[0] for tupla in lista_ordenada]


if "__main__" == __name__:
    
    intput_list = [("Barcelo 4 10"), ("Riu 5 1"), ("Iberostar 5 2"), ("H10 4 99"), ("Sol 3 1000")]
    resultado = quicksort(intput_list)
    
    print(resultado)

#Ejercicio de hacer ecuación de recurrencia con memorization

def solve(p, q):
    
    memo = {}
    
    def calculo(p, q):
        
        if p == q:
            return 1
        
        if (p, q) in memo:
            return memo[(p, q)]
        
        valor_sumatorio = 0
        
        for k in range(p, q):
            
            valor_sumatorio += calculo(p, k) + calculo(k + 1, q)
        
        valor_pq = max(calculo(p + 1, q), valor_sumatorio)
        
        memo[(p, q)] = valor_pq
        
        return memo[(p, q)]
    
    return calculo(p, q)
    
    
if "__main__" == __name__:
    
    resultado = solve(5, 6)
    
    print(resultado)

#Algoritmo de Dijsktra

def build_graph(input_list):
    graph = DiGraph()

    for element in input_list: #Este bucle es así porque la lista recibida quita el primer elemento que es el número de noso y el número de ejes, entonces el número de ejes que antes era 5, desde el elemento 1 al 6 (1, num_edges + 1), pero como le quitamos el primer elemnto será ahora el primer eje el 0, entonces será de (0, num_edges).
        u, v, w = element
        graph.add_edge(u, v, weight=w)
    
    return graph

def dijkstra(G, from_node, to_node):
    distances = {node: float('inf') for node in G.nodes()}
    distances[from_node] = 0
    visited = set()
    
    while len(visited) < len(G.nodes()):
        current_node = None
        min_dist = float('inf')
        
        for node in G.nodes():
            if node not in visited and distances[node] < min_dist:
                min_dist = distances[node]
                current_node = node
        
        if current_node is None or current_node == to_node:
            break
            
        visited.add(current_node)
        
        for neighbor in G.neighbors(current_node):
            if neighbor not in visited:
                # Usamos G.edge para ser compatibles con tu MiniGraph
                # e[2] es el diccionario de datos {'weight': w}
                edge_data = G.edge(current_node, neighbor, data=True)
                
                if edge_data:
                    weight = edge_data[2].get('weight', 1)
                    new_dist = distances[current_node] + weight
                    
                    if new_dist < distances[neighbor]:
                        distances[neighbor] = new_dist
                        
    return distances[to_node]


if "__main__" == __name__:
    
    input_list = [("s", "t", 10), ("s", "y", 5), ("t", "y", 2), ("y", "t", 3), ("t", "x", 1), ("y", "x", 9), ("y", "z", 2), ("z", "x", 6), ("x", "z", 4), ("s", "z", 7)]
    grafo = build_graph(input_list)
    resultado = dijkstra(grafo, "s", "z")
    print(resultado)

#Algoritmo de Prim(chatgix)

def build_graph(input_list):
    graph = Graph()

    for element in input_list: #Este bucle es así porque la lista recibida quita el primer elemento que es el número de noso y el número de ejes, entonces el número de ejes que antes era 5, desde el elemento 1 al 6 (1, num_edges + 1), pero como le quitamos el primer elemnto será ahora el primer eje el 0, entonces será de (0, num_edges).
        u, v, w = element
        graph.add_edge(u, v, weight=w)
    
    return graph

def prim(G, start_node):
    # key[v] es el peso de la arista más barata que conecta v al árbol
    key = {node: float('inf') for node in G.nodes()}
    parent = {node: None for node in G.nodes()}
    visited = set()
    
    key[start_node] = 0
    
    while len(visited) < len(G.nodes()):
        # BÚSQUEDA MANUAL DEL MÍNIMO
        current_node = None
        min_key = float('inf')
        for node in G.nodes():
            if node not in visited and key[node] < min_key:
                min_key = key[node]
                current_node = node
                
        if current_node is None:
            break
            
        visited.add(current_node)
        
        # ACTUALIZACIÓN DE VECINOS
        for neighbor in G.neighbors(current_node):
            if neighbor not in visited:
                edge_data = G.edge(current_node, neighbor, data=True)
                
                if edge_data:
                    weight = edge_data[2].get('weight', 1)
                
                # En Prim, comparamos solo el peso de la arista (no acumulado)
                if weight < key[neighbor]:
                    key[neighbor] = weight
                    parent[neighbor] = current_node
                    
    # Reconstrucción de las aristas del MST
    mst_edges = []
    for node in parent:
        if parent[node] is not None:
            mst_edges.append((parent[node], node, key[node]))
            
    return mst_edges


if "__main__" == __name__:
    
    input_list = [("v0", "v1", 2), ("v0", "v4", 1), ("v1", "v2", 1), ("v4", "v2", 2), ("v4", "v5", 1), ("v2", "v5", -5), ("v5", "v6", -2), ("v6", "v3", -4), ("v3", "v2", -1)]
    grafo = build_graph(input_list)
    resultado = prim(grafo, "v0")
    print(resultado)

#Ejercicio de shortest distance de memorization hecho para la clase minigraph

def build_graph(input_list):
    
    grafo = DiGraph()
    
    for elemento in input_list:
        u, v, w = elemento
        grafo.add_edge(u, v, weight=w)
    
    return grafo

def solve(grafo, from_node, to_node):
    
    memo = {}
    
    def calculo(node):
        
        if node == from_node:
            return 0, [from_node]
        
        if node in memo:
            return memo[node]
        
        minimo_peso = float('inf')
        sendero = []
        
        for pred in grafo.predecessors(node):
            
            edge_data = grafo.edge(pred, node, data=True)
            weight = edge_data[2].get('weight', 1)
            
            peso_actual, sendero_actual = calculo(pred)
            
            if peso_actual + weight < minimo_peso:
                
                minimo_peso = peso_actual + weight
                sendero = sendero_actual + [node]
        
        memo[node] = (minimo_peso, sendero)
        return memo[node]
        
    return calculo(to_node)


if __name__ == "__main__":
    input_list = [
        (7, 1, 1), (7, 3, 2), (7, 5, 5), 
        (1, 2, 4), (1, 4, 3), (3, 2, 9), 
        (3, 4, 5), (3, 6, 16), (5, 6, 22), 
        (2, 8, 18), (4, 8, 13), (6, 8, 2)
    ]
    grafo = build_graph(input_list)
    resultado = solve(grafo, 7, 8)
    print("Distancia mínima y camino:", resultado)

#Ejercicio quicksort con letras

def quicksort(array):
    
    def pivote_y_partir(array):
        
        elementos_menores= []
        elementos_mayores = []
        elementos_iguales = []
        pivote = array[-1]
        
        #Hacemos un bucle hasta el penúltimo elemento del array ya que el último es el pivote
        for i in range(0, len(array) - 1):
            
            elemento_comparar = array[i].lower()
            
            if elemento_comparar < pivote.lower():
                elementos_menores.append(array[i])
            elif elemento_comparar > pivote.lower():
                elementos_mayores.append(array[i])
            else:
                elementos_iguales.append(array[i])
                
        return elementos_menores, elementos_iguales, pivote, elementos_mayores
    
    def divide_y_venceras(array):
        
        #Hay veces que van a haber subarrays vacíos ya que no hay o elementos mayores que el pivote o elementos menores que el pivote
        if len(array) <= 1:
            return array
        
        menores, iguales, pivote, mayores = pivote_y_partir(array)
        
        menores_ordenados = divide_y_venceras(menores)#[]
        mayores_ordenados = divide_y_venceras(mayores)#[2, 5, 7]
    
        #Convertimos al pivote en una lista ya que estamos haciendo operaciones de listas
        return menores_ordenados + iguales + [pivote] + mayores_ordenados
    
    return divide_y_venceras(array)#[1, 2, 5, 7]
    
    
if "__main__" == __name__:
    
    array = ["Clavos medianos", "Sierra electrica", "Llave inglesa", "Destornillador", "Embudo", "Cable corriente", "Generador"]
    resultado = quicksort(array)
    
    print(resultado)

#Contar el número de islas que hay en la matriz

class Stack:
   def __init__(self):
       self.items = []

   def isEmpty(self):
       return self.items == []

   def push(self, item):
       self.items.append(item)

   def pop(self):
       return self.items.pop()

   def peek(self):
       return self.items[len(self.items)-1]

   def size(self):
       return len(self.items)

def contar_islas(matriz):
    
    posiciones_vistas = set()
    filas = len(matriz)
    columnas = len(matriz[0])
    
    alive = Stack()
    
    def dfs():
        
        while alive.isEmpty() != True:
            
            posicion_actual = alive.pop()
            
            if posicion_actual not in posiciones_vistas:
            
                if matriz[posicion_actual[0]][posicion_actual[1]] != 0:
                    posiciones_vistas.add((posicion_actual[0], posicion_actual[1]))
                
                    #Arriba
                    if (posicion_actual[0] - 1) >= 0 and (posicion_actual[0] - 1, posicion_actual[1]) not in posiciones_vistas:
                        alive.push((posicion_actual[0] - 1, posicion_actual[1]))
                    
                    #Izquierda
                    if (posicion_actual[1] - 1) >= 0 and (posicion_actual[0], posicion_actual[1] - 1) not in posiciones_vistas:
                        alive.push((posicion_actual[0], posicion_actual[1] - 1))
                    
                    #Abajo
                    if (posicion_actual[0] + 1) <= filas - 1 and (posicion_actual[0] + 1, posicion_actual[1]) not in posiciones_vistas:
                        alive.push((posicion_actual[0] + 1, posicion_actual[1]))
                    
                    #Derecha
                    if (posicion_actual[1] + 1) <= columnas - 1 and (posicion_actual[0], posicion_actual[1] + 1) not in posiciones_vistas:
                        alive.push((posicion_actual[0], posicion_actual[1] + 1))
        
        return
    
    contador_islas = 0
    
    for i in range(filas):
        for j in range(columnas):
            
            #Cada vez que nos metemos aqui vemos toda la superficie de la isla entonces sumamos solo uno ya que se ve toda la isla
            if (i, j) not in posiciones_vistas and matriz[i][j] != 0:
                contador_islas += 1
                alive.push((i, j))
                dfs()
    
    return contador_islas


if "__main__" == __name__:
    
    matriz = [[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1]]
    resultado = contar_islas(matriz)

    print(resultado)

#Ejercicio de matriz de inundación

class Stack:
   def __init__(self):
       self.items = []

   def isEmpty(self):
       return self.items == []

   def push(self, item):
       self.items.append(item)

   def pop(self):
       return self.items.pop()

   def peek(self):
       return self.items[len(self.items)-1]

   def size(self):
       return len(self.items)

def matriz_inundacion(matriz):
    
    posiciones_vistas = set()
    filas = len(matriz)
    columnas = len(matriz[0])
    matriz_resultado = matriz.copy()
    
    alive = Stack()
        
    alive.push((0, 0))
        
    while alive.isEmpty() != True:
            
        posicion_actual = alive.pop()
            
        if posicion_actual not in posiciones_vistas:
            
            if matriz[posicion_actual[0]][posicion_actual[1]] != 2:
                matriz_resultado[posicion_actual[0]][posicion_actual[1]] = matriz[posicion_actual[0]][posicion_actual[1]] + 1
                posiciones_vistas.add((posicion_actual[0], posicion_actual[1]))
            
            #Arriba
            if (posicion_actual[0] - 1) >= 0 and (posicion_actual[0] - 1, posicion_actual[1]) not in posiciones_vistas:
                alive.push((posicion_actual[0] - 1, posicion_actual[1]))
                
            #Izquierda
            if (posicion_actual[1] - 1) >= 0 and (posicion_actual[0], posicion_actual[1] - 1) not in posiciones_vistas:
                alive.push((posicion_actual[0], posicion_actual[1] - 1))
                
            #Abajo
            if (posicion_actual[0] + 1) <= filas - 1 and (posicion_actual[0] + 1, posicion_actual[1]) not in posiciones_vistas:
                alive.push((posicion_actual[0] + 1, posicion_actual[1]))
                
            #Derecha
            if (posicion_actual[1] + 1) <= columnas - 1 and (posicion_actual[0], posicion_actual[1] + 1) not in posiciones_vistas:
                alive.push((posicion_actual[0], posicion_actual[1] + 1))
    
    return matriz_resultado


if "__main__" == __name__:
    
    matriz = [[1, 1, 0], [-1, 2, 0], [0, 1, -1]]
    resultado = matriz_inundacion(matriz)

    print(resultado)

#(MUY DIFICIL) Ejercicio de hacer un sudoku con backtracking

import copy

def sudoku(matriz):
    
    soluciones = []
    matriz_resultado = copy.deepcopy(matriz)
    
    def misma_fila(tablero, i, fila_actual):
        
        elementos_fila = [element for element in tablero[fila_actual]]
        
        if i in elementos_fila:
            return True

        return False

    def misma_columna(tablero, i, columna_actual):
        
        elementos_columna = [tablero[j][columna_actual] for j in range(0, 9)]
        
        if i in elementos_columna:
            return True
        
        return False
    
    def mismo_cuadrado(tablero, i, fila_actual, columna_actual):
        
        #Esta funcion me ayudo chatgix porque telita
        
        inicio_filas = (fila_actual // 3) * 3
        inicio_columnas = (columna_actual // 3) * 3
        
        elementos_cuadrado = []
        
        for j in range(inicio_filas, inicio_filas + 3):
            for k in range(inicio_columnas, inicio_columnas + 3):
                elementos_cuadrado.append(tablero[j][k])

        if i in elementos_cuadrado:
            return True
        
        return False

    def backtracking(fila_actual, columna_actual, numeros_puestos):
        
        if len(soluciones) >= 1: return
        
        if numeros_puestos == len(matriz) * len(matriz[0]):
            soluciones.append([fila[:] for fila in matriz_resultado])
            return
        
        #Esto me ayudo un poco el chatgix porque lo puse dentro del bucle y así es mejor
        if columna_actual == len(matriz[0]) - 1:
            sig_fila, sig_col = fila_actual + 1, 0
        else:
            sig_fila, sig_col = fila_actual, columna_actual + 1
        
        if matriz[fila_actual][columna_actual] != -1:
            backtracking(sig_fila, sig_col, numeros_puestos + 1)
            return
        
        for i in range(1, 10):
            
            if misma_fila(matriz_resultado, i, fila_actual):
                continue
            
            if misma_columna(matriz_resultado, i, columna_actual):
                continue
            
            if mismo_cuadrado(matriz_resultado, i, fila_actual, columna_actual):
                continue
            
            matriz_resultado[fila_actual][columna_actual] = i
            backtracking(sig_fila, sig_col, numeros_puestos + 1)
            matriz_resultado[fila_actual][columna_actual] = -1
        
        return
    
    backtracking(0, 0, 0)
    
    return soluciones
    
    
if "__main__" == __name__:
    
    matriz = [
        [-1, 7, -1, -1, 2, -1, -1, 4, 6],
        [-1, 6, -1, -1, -1, -1, 8, 9, -1], 
        [2, -1, -1, 8, -1, -1, 7, 1, 5], 
        [-1, 8, 4, -1, 9, 7, -1, -1, -1], 
        [7, 1, -1, -1, -1, -1, -1, 5, 9], 
        [-1, -1, -1, 1, 3, -1, 4, 8, -1], 
        [6, 9, 7, -1, -1, 2, -1, -1, 8], 
        [-1, 5, 8, -1, -1, -1, -1, 6, -1], 
        [4, 3, -1, -1, 8, -1, -1, 7, -1]
    ]
    resultado = sudoku(matriz)
    
    print(resultado)

#Los siguientes ejercicios se pueden hacer de manera más óptima, pero con encontrar una solución ya estoy satisfecho

#(MUY DIFICIL) Ejercicio de contar el número de bloques de agua de lluvia, es un ejercicio hard de leetcode

def gotas_agua(array):
    
    total_agua = 0
    #Hacemos un set por si acaso ya contamos esos agujeros de un lado no contarlos de nuevo
    posiciones_vistas = set()
    
    #Funcion que cuenta el número de bloques de agua cuando se detecta un agujero
    def recuento(indice1, indice2, array):#7, 8, array
        
        total_agua_almacenada = 0#
        altura_inicial = array[indice1]#2
        for i in range(indice1 + 1, indice2):#9
            if i not in posiciones_vistas:
                agua_almacenada = altura_inicial - array[i]
                posiciones_vistas.add(i)
                if agua_almacenada < 0:
                    continue
                
                total_agua_almacenada += agua_almacenada
        
        return total_agua_almacenada
    
    #Funciones que miran de ambos lados para no perderse de ningún agujero
    
    def izquierda_a_derecha(array):
        
        nonlocal total_agua
        
        i, j = 0, 0#1, 2
        altura_izquierda = array[i]#3
        
        while j < len(array):
            
            #Si el primer valor es 0, sumamos a los indices hasta encontrar un muro
            if array[i] == 0:
                i += 1
                j = i + 1
                altura_izquierda = array[i]
                continue
            
            altura_derecha = array[j]#2
            if altura_derecha >= altura_izquierda:
                total_agua += recuento(i, j, array)
                i = j
                j = i + 1
                altura_izquierda = array[i]
            else:
                j += 1
        
        return
    
    def derecha_a_izquierda(array):
        
        nonlocal total_agua
        
        i, j = len(array) - 1, len(array) - 2#10, 9
        
        altura_derecha = array[i]#0
        
        while j >= 0:
            
            #Si el primer valor es 0, sumamos a los indices hasta encontrar un muro
            if array[i] == 0:
                i -= 1
                j = i - 1
                continue
            
            altura_izquierda = array[j]#3
            if altura_izquierda >= altura_derecha:
                total_agua += recuento(j, i, array)
                i = j
                j = i - 1
                altura_derecha = array[i]
            else:
                j -= 1
        
        return
    
    #Ejecutamos los 2 lados y luego devolvemos el total de bloques de agua que hay
    izquierda_a_derecha(array)
    derecha_a_izquierda(array)
    
    return total_agua


if "__main__" == __name__:
    
    array = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
    resultado = gotas_agua(array)
    
    print(resultado)

#(MUY DIFICIL) Ejercicio de encontrar el rectangulo más grande expandiendo, es un ejercicio hard de leetcode

def rectangulos(array):
    
    maximo_rectangulo = 0#6
    
    def expandir_rectangulo(indice, array):#2, array
        
        #El rectangulo total tiene un valor minimo del propio rectangulo
        altura_actual = array[indice]#5
        rectangulo_total = altura_actual#5

        #Si el indice están en el limite entonces o no podrá tener indice izq o der
        if indice != 0:
            indice_izquierdo = indice - 1
        else:
            indice_izquierdo = -1
        
        if indice != len(array) - 1:
            indice_derecho = indice + 1
        else:
            indice_derecho = len(array)
        
        #Mientras no se acaben las expansiones, seguimos expandiendo
        while indice_izquierdo > 0 or indice_derecho < len(array) - 1:#-1, 3
            
            #Si en algún momento el rectangulo de algún lado no es mayor o igual entonces hacemos que el índice se salte del límite para que termine de expandir
            if indice_izquierdo >= 0:
                if array[indice_izquierdo] >= altura_actual:
                    rectangulo_total += altura_actual
                    indice_izquierdo -= 1
                else:
                    indice_izquierdo = -1
            
            if indice_derecho <= len(array) - 1:
                if array[indice_derecho] >= altura_actual:
                    rectangulo_total += altura_actual
                    indice_derecho += 1
                else:
                    indice_derecho = len(array)
        
        return rectangulo_total
    
    #Hacemos un bucle para conseguir el mayor rectángulo posible expandiendo cada uno
    for i in range(len(array)):
        rectangulo_calculado = expandir_rectangulo(i, array)
        if rectangulo_calculado > maximo_rectangulo:
            maximo_rectangulo = rectangulo_calculado
    
    return maximo_rectangulo


if "__main__" == __name__:
    
    array = [2, 1, 5, 6, 2, 3]
    resultado = rectangulos(array)
    
    print(resultado)

#Ejercicio de encontrar el contenedor de agua más grande, es un ejercicio medio de leetcode

def cuadrados_agua(array):
    
    maxima_area = 0#0
    j = len(array) - 1#8
    
    while j >= 0:
        
        for i in range(0, j):#0-7
            area_actual = abs(i - j) * min(array[i], array[j])
            if area_actual > maxima_area:
                maxima_area = area_actual
        
        j -= 1
    
    return maxima_area


if "__main__" == __name__:
    
    array = [1, 8, 6, 2, 5, 4, 8, 3, 7]
    resultado = cuadrados_agua(array)
    
    print(resultado)

#(MUY DIFICIL) Ejercicio de encontrar la substring más pequeña de s que tenga todas las letras de la string t, es un ejercicio hard de leetcode

class Queue:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def enqueue(self, item):
        self.items.insert(0,item)

    def dequeue(self):
        return self.items.pop()
    
    def belong(self, item):
        return item in self.items

    def size(self):
        return len(self.items)

def window_string(s, t):
    
    listas_substrings = []#[BCA]
    
    def ordenacion_longitudes(listas_substrings, elemento):
        
        if len(listas_substrings) == 0:
            listas_substrings.append(elemento)
            return
        
        if len(listas_substrings) == 1 and len(elemento) < len(listas_substrings[0]):
            listas_substrings[0] = elemento
            return
    
    if len(s) == 0:
        return ""
    
    cola = Queue()#[(C, 4)(ANC, 4), (BANC, 4)]
    
    i = 0
        
    cola.enqueue((s[i], i + 1))#
        
    while cola.isEmpty() != True:
                
        letra_actual = cola.dequeue()#(BANC, 4)
            
        letra_actualmente = letra_actual[0]#BANC
            
        letra_a_mirar = letra_actualmente[-1]#C
            
        if letra_a_mirar in t and len(letra_actualmente) != 1:
            if not cola.belong((letra_a_mirar, i)):
                cola.enqueue((letra_a_mirar, i + 1))
            
        if all(letra in letra_actualmente for letra in t):
            ordenacion_longitudes(listas_substrings, letra_actualmente)
            continue
        
        i = letra_actual[1]
         
        if i < len(s):
            añadir = letra_actual[0] + s[i]
            cola.enqueue((añadir, i + 1))
    
    return listas_substrings[0]


if "__main__" == __name__:
    
    resultado = window_string("ADOBECODEBANC", "ABC")
    
    print(resultado)
